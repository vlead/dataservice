#+TITLE: Dataservice
#+Author: VLEAD
#+Date: [2015-08-13 Thu]
#+PROPERTY: results output
#+PROPERTY: exports code
#+SETUPFILE: org-templates/level-0.org

* Introduction
  =dataservice= is a micro service that allows persistence of data by
  other micro services over HTTP using REST API.  =dataservice= hides
  the implementation details of the data store that is required for
  data persistence.

* Requirements
  1. The model of the data on whose foundation =dataservice= is built
     is explicitly laid out.(v0.1.0) <<req1>>
  2. Python API is provided as a wrapper to make CRUD operations on
     the data. (v0.1.0)
  3. REST API is provided for various applications to perform CRUD operations
     on the data. (v0.2.0)
  4. A bulk update interface, to update bulk data at once. <<req4>>. This
     requirement was deemed not necessary as [[https://issues.vlabs.ac.in/issues/133#note-4][#133]].
  5. Feedback portal to save data to data service. (v0.2.0)
  6. A weekly dump of the feedback data to an excel file. (v0.2.0)

* Design & Implementation
** Some initialization and boilerplate code
*** __init__
#+BEGIN_SRC python :tangle src/__init__.py :eval no
print "src package"
import db

#+END_SRC
*** imports
#+BEGIN_SRC python :tangle src/db.py :eval no
# -*- coding: utf-8 -*-

from collections import OrderedDict

from flask.ext.sqlalchemy import SQLAlchemy
from flask import current_app

import sqlalchemy.types as types

import re
from urlparse import urlparse
from datetime import datetime
import json

from ds_exceptions import AttributeRequired
from utils import typecheck

db = SQLAlchemy()


class JSONType(types.TypeDecorator):
    impl = types.UnicodeText

    def process_bind_param(self, value, engine):
        if value:
            return json.dumps(value)

    def process_result_value(self, value, engine):
        if value:
            return json.loads(value)
        else:
            # default can also be a list
            return {}


# Abstract class to hold common methods
class Entity(db.Model):

    __abstract__ = True

    # save a db.Model to the database. commit it.
    def save(self):
        db.session.add(self)
        db.session.commit()

    # update the object, and commit to the database
    def update(self, **kwargs):
        for attr, val in kwargs.iteritems():
            setter_method = "set_" + attr
            try:
                self.__getattribute__(setter_method)(val)
            except Exception as e:
                raise e

        self.save()

    #print "Setting new val"
    #print "Calling %s on %s" % (method_to_set, curr_entity)
    #try:
    #    getattr(record, method_to_set)(new_val)
    #except Exception as e:
    #pass

    def delete(self):
        db.session.delete(self)
        db.session.commit()

#+END_SRC

** The Data Model
   TODO: More description of the data model.

*** Name

     Name is an alphabetical string.

#+BEGIN_SRC python :tangle src/db.py :eval no
class Name(object):
    def __init__(self, value):
        # if the string contains any non-alphabet and non-space character, raise
        # a type error
        if re.search('[^a-zA-Z. ]+', value):
            raise TypeError('%s is not a Name!' % value)

        self.value = value
#+END_SRC
*** Email

     Email is a type as defined in RFC [[https://tools.ietf.org/html/rfc5321][5321]], [[https://tools.ietf.org/html/rfc5322][5322]] and [[https://tools.ietf.org/html/rfc6531][6531]].
     Following is the constructor for this class.

#+BEGIN_SRC python :tangle src/db.py :eval no
class Email(object):
    def __init__(self, value):
        if not re.search('[^@]+@[^@]+\.[^@]+', value):
            raise TypeError('%s is not an email!' % value)
        self.value = value
#+END_SRC
*** URL

   URL is a type as defined in RFC [[https://www.ietf.org/rfc/rfc1738.txt][1738]].

#+BEGIN_SRC python :tangle src/db.py :eval no
class URL(object):
    def __init__(self, value):
        result = urlparse(value)
        if not result.scheme or not result.netloc:
            raise TypeError("%s is not a valid URL." % value)

        self.value = value
#+END_SRC
*** LabId

     LabId is of type string

*** InstituteId

     InstituteId is of type string

*** DisciplineId

     DisciplineId is of type string

*** IntegrationLevel


     IntegrationLevel is {0, 1, 2, 3, 4, 5, 6}.


#+BEGIN_SRC python :tangle src/db.py :eval no
class IntegrationLevel(Entity):
    __tablename__ = 'integration_levels'
    id = db.Column(db.Integer, primary_key=True)
    level = db.Column(db.Integer, nullable=False, unique=True)

    labs = db.relationship('Lab', backref='integration_level')

    @staticmethod
    def get_by_id(id):
        return IntegrationLevel.query.get(id)

    @staticmethod
    def get_by_level(level):
        return IntegrationLevel.query.filter_by(level=level).first()

    def to_client(self):
        return {
            'id': self.id,
            'level': self.level
        }

#+END_SRC
*** HostingPlatform

     HostingPlatform is {IIIT, Badal, AWS, Else}.

#+BEGIN_SRC python :tangle src/db.py :eval no
class HostingPlatform(Entity):
    __tablename__ = 'hosting_platforms'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(32), nullable=False, unique=True)

    labs = db.relationship('Lab', backref='hosted_on')

    @staticmethod
    def get_by_id(id):
        return HostingPlatform.query.get(id)

    @staticmethod
    def get_by_platform(platform):
        return HostingPlatform.query.filter_by(name=platform).first()

    def to_client(self):
        return {
            'id': self.id,
            'name': self.name
        }

#+END_SRC
*** TypeOfLab

     TypeOfLab is
     { Simulation,
     Remote Triggered,
     Simulation and Remote Triggered,
     Pilot Phase }

#+BEGIN_SRC python :tangle src/db.py :eval no
class TypeOfLab(Entity):
    __tablename__ = 'type_of_labs'
    id = db.Column(db.Integer, primary_key=True)
    type = db.Column(db.String(64), nullable=False, unique=True)

    labs = db.relationship('Lab', backref='type_of_lab')

    @staticmethod
    def get_by_id(id):
        return TypeOfLab.query.get(id)

    @staticmethod
    def get_by_type(type):
        return TypeOfLab.query.filter_by(type=type).first()

    def to_client(self):
        return {
            'id': self.id,
            'type': self.type
        }

#+END_SRC

*** Institute

**** Immutable Data
     This is the data associated with Institute type, which is immutable.

     + Id
     + InstituteId

**** Mutable Data

     These are the data associated with Institute type, which are mutable

     + Name
     + PIC
     + PIC Email
     + IIC
     + IIC Email

**** InstituteId assigned to each institute
     |---------------------------------+-------------|
     | Name                            | InstituteId |
     |---------------------------------+-------------|
     | IIIT Hyderabad                  | iiith       |
     | IIT Bombay                      | iitb        |
     | IIT Delhi                       | iitd        |
     | IIT Roorkee                     | iitr        |
     | IIT Guwahati                    | iitg        |
     | IIT Kanpur                      | iitk        |
     | IIT Kharagpur                   | iitkgp      |
     | IIT Madras                      | iitm        |
     | NIT Surathkal                   | nitk        |
     | Amrita University               | amrita      |
     | College of Engineering, Pune    | coep        |
     | Dayalbagh Educational Institute | dei         |
     |---------------------------------+-------------|

**** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Institute(Entity):

    __tablename__ = 'institutes'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    institute_id = db.Column(db.String(16), nullable=False, unique=True)
    pic = db.Column(db.String(128))
    pic_email = db.Column(db.String(128))
    iic = db.Column(db.String(128))
    iic_email = db.Column(db.String(128))

    labs = db.relationship('Lab', backref='institute')
    developers = db.relationship('Developer', backref='institute')

#+END_SRC

**** Constructor for the Institute
      Signature of the constructor is as follows. Fields in [...]  are
      optional. Others are mandatory.
#+BEGIN_EXAMPLE
    institute = Institute(name=String,
                          institute_id=String
                          [,pic=<instance of class Name>]
                          [,pic_email=<instance of class Email>]
                          [,iic=<instance of class Name>]
                          [,iic_email=<instance of class Email>])
#+END_EXAMPLE

#+BEGIN_SRC python :tangle src/db.py :eval no
    def __init__(self, **kwargs):
        if 'institute_id' not in kwargs:
            raise AttributeRequired("institute_id is required when initializing an institute")
        self.institute_id = kwargs['institute_id']

        if 'name' not in kwargs:
            raise AttributeRequired("name is required when initializing an institute")

        self.set_name(kwargs['name'])

        if 'pic' in kwargs:
            self.set_pic(kwargs['pic'])

        if 'pic_email' in kwargs:
            self.set_pic_email(kwargs['pic_email'])

        if 'iic' in kwargs:
            self.set_iic(kwargs['iic'])

        if 'iic_email' in kwargs:
            self.set_iic_email(kwargs['iic_email'])

        self.save()
#+END_SRC

**** Functions that operate on Institute domain
***** getAll: Nil --> set[Institute]
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_all():
        return Institute.query.all()

#+END_SRC
***** getName: Institute --> Name
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_name(self):
        return self.name

#+END_SRC

***** getId: Institute --> Id
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_id(self):
        return self.id

#+END_SRC

***** getInstitute: Id --> Institute
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_by_id(id):
        return Institute.query.get(id)

#+END_SRC

***** getInstituteId: Institute --> InstituteId
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_institute_id(self):
        return self.institute_id

#+END_SRC

***** getInstitute: InstituteId --> Institute
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_by_institute_id(institute_id):
        return Institute.query.filter_by(institute_id=institute_id).first()

#+END_SRC

***** getPIC: Institute --> Name
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_pic(self):
        return self.pic

#+END_SRC

***** getPICEmail: Institute --> Email
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_pic_email(self):
        return self.pic_email

#+END_SRC


***** getIIC: Institute --> Name
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_iic(self):
        return self.iic

#+END_SRC

***** getIICEmail: Institute --> Email
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_iic_email(self):
        return self.iic_email

#+END_SRC

***** getLabs: Institute --> set[Lab]
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_labs(self):
        return self.labs

#+END_SRC

***** getDevelopers: Institute --> set[Developer]
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_developers(self):
        return self.developers

#+END_SRC

***** setPIC: Institute, Name --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(pic=Name)
    def set_pic(self, pic):
        self.pic = pic.value
#+END_SRC

***** setPICEmail: Institute, Email --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(pic_email=Email)
    def set_pic_email(self, pic_email):
        self.pic_email = pic_email.value
#+END_SRC

***** setIIC: Institute, Name --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(iic=Name)
    def set_iic(self, iic):
        self.iic = iic.value
#+END_SRC

***** setIICEmail: Institute, Email --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(iic_email=Email)
    def set_iic_email(self, iic_email):
        self.iic_email = iic_email.value
#+END_SRC

***** setName: Institute, Name --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(name=str)
    def set_name(self, name):
        self.name = name
#+END_SRC

***** to_client
#+BEGIN_SRC python :tangle src/db.py :eval no
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name,
            'institute_id': self.institute_id,
            'pic': self.pic,
            'pic_email': self.pic_email,
            'iic': self.iic,
            'iic_email': self.iic_email,
        }

#+END_SRC

***** to_csv
#+BEGIN_SRC python :tangle src/db.py :eval no
    def to_csv(self):
        d = OrderedDict()
        d['id'] = self.institute_id
        d['name'] = self.name
        d['pic'] = self.pic
        d['pic_email'] = self.pic_email
        d['iic'] = self.iic
        d['iic_email'] = self.iic_email
        return d
#+END_SRC
*** Discipline
**** Immutable Data
     This is the data associated with Discipline type, which is immutable.

     + Id
     + DisciplineId

**** Mutable Data
     This is the data associated with Discipline type, which is mutable.

     + Name
     + DNC
     + DNC Email

**** DisciplineId assigned to each discipline
     |------------------------------------------+--------------|
     | Name                                     | DisciplineId |
     |------------------------------------------+--------------|
     | Aerospace Engineering                    | aero         |
     | Biotechnology and Biomedical Engineering | biotech      |
     | Chemical Engineering                     | chem-engg    |
     | Chemical Sciences                        | chem         |
     | Civil Engineering                        | civil        |
     | Computer Science and Engineering         | cse          |
     | Electrical Engineering                   | ee           |
     | Electronics and Communication            | ece          |
     | Humanities                               | human        |
     | Mechanical Engineering                   | mech         |
     | Physical Sciences                        | phy-sc       |
     | Textile Engineering                      | tex-engg     |
     | Design Engineering                       | dsgn-engg    |
     | Material Sciences                        | mat-sc       |
     |------------------------------------------+--------------|

**** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Discipline(Entity):

    __tablename__ = 'disciplines'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    discipline_id = db.Column(db.String(16), nullable=False, unique=True)
    dnc = db.Column(db.String(64))
    dnc_email = db.Column(db.String(64))

    labs = db.relationship('Lab', backref='discipline')

#+END_SRC

**** Constructor for the Discipline
      Signature of the constructor is as follows. Fields in [...]  are
      optional. Others are mandatory.
#+BEGIN_EXAMPLE
    discipline = Discipline(name=String,
                            discipline_id=String
                            [,dnc=<instance of class Name>]
                            [,dnc_email=<instance of class Email>])
#+END_EXAMPLE

#+BEGIN_SRC python :tangle src/db.py :eval no
    def __init__(self, **kwargs):
        if 'discipline_id' not in kwargs:
            raise AttributeRequired("discipline_id is required when initializing discipline")

        self.discipline_id = kwargs['discipline_id']

        if 'name' not in kwargs:
            raise AttributeRequired("name is required when initializing discipline")

        self.name = kwargs['name']

        if 'dnc' in kwargs:
            self.set_dnc(kwargs['dnc'])

        if 'dnc_email' in kwargs:
            self.set_dnc_email(kwargs['dnc_email'])

#+END_SRC

**** Functions that operate on Discipline domain
***** getAll: Nil --> set[Discipline]
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_all():
        return Discipline.query.all()

#+END_SRC

***** getId: Discipline --> Id
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_id(self):
        return self.id

#+END_SRC

***** getName: Discipline --> Name
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_name(self):
        return self.name

#+END_SRC
***** getDiscipline: Id --> Discipline
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_by_id(id):
        return Discipline.query.get(id)

#+END_SRC

***** getDisciplineId: Discipline --> DisciplineId
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_discipline_id(self):
        return self.discipline_id

#+END_SRC

***** getDiscipline: DisciplineId --> Discipline
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_by_discipline_id(discipline_id):
        return Discipline.query.filter_by(discipline_id=discipline_id).first()

#+END_SRC

***** getLabs: Discipline --> set[Lab]
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_labs(self):
        return self.labs

#+END_SRC

***** getDNC: Discipline --> Name
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_dnc(self):
        return self.dnc

#+END_SRC

***** getDNCEmail: Discipline --> Email
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_dnc_email(self):
        return self.dnc_email

#+END_SRC

***** setName: Discipline --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(name=str)
    def set_name(self, name):
        self.name = name
        self.save()
#+END_SRC

***** setDNC: Discipline, Name --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(name=Name)
    def set_dnc(self, name):
        self.dnc = name.value
        self.save()
#+END_SRC

***** setDNCEmail: Discipline, Email --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(email=Email)
    def set_dnc_email(self, email):
        self.dnc_email = email.value
        self.save()
#+END_SRC

***** to_client
#+BEGIN_SRC python :tangle src/db.py :eval no
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name,
            'discipline_id': self.discipline_id,
            'dnc': self.dnc,
            'dnc_email': self.dnc_email
        }

#+END_SRC

***** to_csv
#+BEGIN_SRC python :tangle src/db.py :eval no
    def to_csv(self):
        d = OrderedDict()
        d['id'] = self.discipline_id
        d['name'] = self.name
        d['dnc'] = self.dnc
        d['dnc_email'] = self.dnc_email
        return d
#+END_SRC
*** Developer
**** Immutable Data
     This is the data associated with Developer type, which is immutable.
     + Id
**** Mutable Data
     This is the data associated with Developer type, which is mutable.
     + Name
     + Email
     + Institute --> Id

**** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Developer(Entity):

    __tablename__ = 'developers'

    id = db.Column(db.Integer, primary_key=True)

    name = db.Column(db.String(64), nullable=False)
    email = db.Column(db.String(128), unique=True)
    institute_id = db.Column(db.Integer, db.ForeignKey('institutes.id'))

#+END_SRC
**** Constructor
      Signature of constructor
#+BEGIN_EXAMPLE
    developer = Developer(name=<instance of class Name>,
                          email=<instance of Email>,
                          institute=<instance of Institute>)
#+END_EXAMPLE
#+BEGIN_SRC python :tangle src/db.py :eval no
    def __init__(self, **kwargs):
        if 'name' not in kwargs:
            raise AttributeRequired("mandatory attribute `name` is missing")
        self.set_name(kwargs['name'])

        if 'email' not in kwargs:
            raise AttributeRequired("mandatory attribute `email` is missing")
        self.set_email(kwargs['email'])

        if 'institute' not in kwargs:
            raise AttributeRequired("mandatory attribute `institute` is missing")
        self.set_institute(kwargs['institute'])

    def __str__(self):
        return "Name = %s, e-mail id = %s, institute = %s" % \
            (self.name, self.email, self.institute.name)

    def __repr__(self):
        return "Name = %s, e-mail id = %s, institute = %s" % \
            (self.name, self.email, self.institute.name)

#+END_SRC

**** Functions that operate on the Developer domain
***** getAll: Nil --> set[Developer]
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_all():
        return Developer.query.all()

#+END_SRC
***** getId: Developer --> Id
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_id(self):
        return self.id
#+END_SRC

***** getDeveloper: Id --> Developer
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_by_id(id):
        return Developer.query.get(id)
#+END_SRC

***** getName: Developer --> Name
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_name(self):
        return self.name
#+END_SRC

***** getEmail: Developer --> Email
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_email(self):
        return self.email
#+END_SRC

***** getLabs: Developer --> set[Lab]
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_labs(self):
        return self.labs
#+END_SRC

***** getInstitute: Developer --> Institute
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_institute(self):
        return self.institute

#+END_SRC

***** setName: Developer, Name --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(name=Name)
    def set_name(self, name):
        self.name = name.value

#+END_SRC

***** setEmail: Developer, Email --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(email=Email)
    def set_email(self, email):
        self.email = email.value
        self.save()
#+END_SRC
***** setInstitute: Developer, Institute --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(institute=Institute)
    def set_institute(self, institute):
        self.institute = institute
        self.save()
#+END_SRC

***** to_client
#+BEGIN_SRC python :tangle src/db.py :eval no
    def to_client(self):
        return {
            'id': self.id,
            'email': self.email,
            'name': self.name,
            'institute': self.institute.to_client()
        }
#+END_SRC

***** to_csv
#+BEGIN_SRC python :tangle src/db.py :eval no
    def to_csv(self):
        d = OrderedDict()
        d['email'] = self.email
        d['name'] = self.name
        d['institute_id'] = self.institute.institute_id
        return d
#+END_SRC

*** Technology
**** Immutable Data
     This is the data associated with Technology type, which is immutable.

     + Id

**** Mutable Data
     These are the data associated with Technology type, which are mutable.

     + Name
     + Version
     + FOSS

**** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Technology(Entity):

    __tablename__ = 'technologies'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), nullable=False)
    version = db.Column(db.String(32))
    foss = db.Column(db.Boolean)
#+END_SRC

**** Constructor for Technology
      Signature for the constructor is as follows. Attributes inside [...] are
      optional. Other attributes are mandatory.
#+BEGIN_EXAMPLE python
Technology(name=String
           [,version=String]
           [,foss=Boolean])
#+END_EXAMPLE
#+BEGIN_SRC python :tangle src/db.py :eval no
    def __init__(self, **kwargs):
        if 'name' not in kwargs:
            raise AttributeRequired('`name` attribute is required to'
                                    ' initialize Technology')
        self.set_name(kwargs['name'])

        if 'version' in kwargs:
            self.set_version(kwargs['version'])

        if 'foss' in kwargs:
            self.set_foss(kwargs['foss'])

#+END_SRC
**** Functions that operate on the Technology domain
***** getId: Technology --> Id
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_id(self):
        return self.id

#+END_SRC

***** getName: Technology --> String
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_name(self):
        return self.name

#+END_SRC

***** getAll: Nil --> set[Technology]
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_all():
        return Technology.query.all()

#+END_SRC

***** getLabs: Technology --> set[Lab]
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_labs(self):
        return self.labs

#+END_SRC

***** getTechnology: Id --> Technology
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_by_id(id):
        return Technology.query.get(id)

#+END_SRC

***** getVersion: Technology --> Version
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_version(self):
        return self.version

#+END_SRC

***** isFOSS: Technology --> Boolean
#+BEGIN_SRC python :tangle src/db.py :eval no
    def is_foss(self):
        return self.foss

#+END_SRC

***** setName: Technology, String --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(name=str)
    def set_name(self, name):
        self.name = name
        self.save()
#+END_SRC
***** setVersion: Technology, Version --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(version=str)
    def set_version(self, version):
        self.version = version
        self.save()
#+END_SRC

***** setFOSS: Technology, Boolean --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(foss=bool)
    def set_foss(self, foss):
        self.foss = foss
        self.save()
#+END_SRC

***** to_client: Technology --> Dictionary
       Returns a dictionary of necessary attributes for a client to consume
       all the attributes of a technology
#+BEGIN_SRC python :tangle src/db.py :eval no
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name,
            'version': self.version,
            'foss': self.foss
        }
#+END_SRC

***** to_csv
#+BEGIN_SRC python :tangle src/db.py :eval no
    def to_csv(self):
        d = OrderedDict()
        d['name'] = self.name
        d['version'] = self.version
        d['foss'] = self.foss
        return d
#+END_SRC

*** Experiment
**** Immutable Data
     This is the data associated with Experiment type, which is immutable.

     + Id

**** Mutable Data
     These are the data associated with Experiment type, which are mutable.

     + Name
     + ContentURL
     + SimulationURL
     + ContentHostedOn
     + SimulationHostedOn

**** Association
#+BEGIN_SRC python :tangle src/db.py :eval no
# association table of technologies and experiments
technologies_used_expt = db.Table(
    'technologies_used_expt',
    db.Column('expt_id', db.Integer, db.ForeignKey('experiments.id')),
    db.Column('tech_id', db.Integer, db.ForeignKey('technologies.id'))
)
#+END_SRC
**** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Experiment(Entity):

    __tablename__ = 'experiments'

    id = db.Column(db.Integer, primary_key=True)

    # Our data set has really, really long experiment names and URLs!!
    name = db.Column(db.String(256))

    lab_id = db.Column(db.Integer, db.ForeignKey('labs.id'))

    content_url = db.Column(db.String(256))
    # content_on = db.Column(db.Enum('CPE', 'ELSE', 'NA'))
    content_on_id = db.Column(db.ForeignKey('hosting_platforms.id'))
    content_hosted_on = db.relationship('HostingPlatform',
                                 foreign_keys=[content_on_id])

    simulation_url = db.Column(db.String(256))
    # simulation_on = db.Column(db.Enum('CPE', 'ELSE', 'NA'))
    simulation_on_id = db.Column(db.ForeignKey('hosting_platforms.id'))
    simulation_hosted_on = db.relationship('HostingPlatform',
                                    foreign_keys=[simulation_on_id])

    technologies = db.relationship('Technology',
                                   secondary=technologies_used_expt,
                                   backref='experiments')

#+END_SRC

**** Constructor for the Experiment
     Signature of the constructor is as follows. Attributes inside [...]  are
     optional. Others are mandatory.

     Lab is a mandatory part of the constructor, since an experiment can not
     exist independent of a lab. Once lab is created, the creation of an experiment
     must be linked to this lab.
#+BEGIN_EXAMPLE
    experiment = Experiment(name=String,
                            lab=<instance of Lab>
                            [,content_url=<instance of class URL>]
                            [,simulation_url=<instance of class URL>]
                            [,content_hosted_on=<instance of class HostingPlatform>]
                            [,simulation_hosted_on=<instance of class HostingPlatform>]
                            [,technologies=<list type attribute where each item belongs to class Technology>])
#+END_EXAMPLE

#+BEGIN_SRC python :tangle src/db.py :eval no
    def __init__(self, **kwargs):
        if 'lab' not in kwargs:
            raise AttributeRequired("lab is required when initializing experiment")

        self.lab = kwargs['lab']

        if 'name' not in kwargs:
            raise AttributeRequired("name is required when initializing experiment")

        self.set_name(kwargs['name'])

        if 'content_url' in kwargs:
            self.set_content_url(kwargs['content_url'])

        if 'simulation_url' in kwargs:
            self.set_simulation_url(kwargs['simulation_url'])

        if 'technologies' in kwargs:
            if not isinstance(kwargs['technologies'], list):
                raise TypeError('`technologies` attribute should be of list'
                                ' type and each item belongs to Technology class')
            for technology in kwargs['technologies']:
                self.add_technology(technology)

        if 'content_hosted_on' in kwargs:
            self.set_content_hosted_on(kwargs['content_hosted_on'])

        if 'simulation_hosted_on' in kwargs:
            self.set_simulation_hosted_on(kwargs['simulation_hosted_on'])

#+END_SRC

**** Functions that operate on the Experiment domain

***** update: Experiment --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    # update the object, and commit to the database
    def update(self, **kwargs):

        for attr, val in kwargs.iteritems():
            # if the attr is any of the following the setter method names are
            # not straightforward. And then directly assign the given list to
            # the attribute
            if attr in ('technologies'):
                self.__setattr__(attr, val)

            # else it is a attribute where the setter method name matches!
            else:
                setter_method = "set_" + attr
                try:
                    self.__getattribute__(setter_method)(val)
                except Exception as e:
                    raise e

        self.save()
#+END_SRC

***** getAll: Nil --> set[Experiment]
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_all():
        return Experiment.query.all()

#+END_SRC
***** getName: Experiment --> Name
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_name(self):
        return self.name

#+END_SRC

***** getId: Experiment --> Id
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_id(self):
        return self.id

#+END_SRC

***** getExperiment: Id --> Experiment
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_by_id(id):
        return Experiment.query.get(id)

#+END_SRC

***** getContentURL: Experiment --> URL + Nil
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_content_url(self):
        return self.content_url

#+END_SRC

***** getSimulationURL: Experiment --> URL + Nil
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_simulation_url(self):
        return self.simulation_url

#+END_SRC

***** getTechnologies: Experiment --> set[Technology]
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_technologies(self):
        return self.technologies

#+END_SRC

***** contentHostedOn: Experiment --> HostingPlatform + Nil
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_content_hosted_on(self):
        return self.content_hosted_on

#+END_SRC

***** simulationHostedOn: Experiment --> HostingPlatform + Nil
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_simulation_hosted_on(self):
        return self.simulation_hosted_on

#+END_SRC

***** getLab: Experiment --> Lab
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_lab(self):
        return self.lab

#+END_SRC
a
***** setName: Experiment, Name --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(name=str)
    def set_name(self, name):
        self.name = name
        self.save()
#+END_SRC

***** setContentURL: Experiment, URL --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(url=URL)
    def set_content_url(self, url):
        self.content_url = url.value
        self.save()

#+END_SRC

***** setSimulationURL: Experiment, URL --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(url=URL)
    def set_simulation_url(self, url):
        self.simulation_url = url.value
        self.save()

#+END_SRC

***** setContentHostedOn: Experiment, HostingPlatform --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(platform=HostingPlatform)
    def set_content_hosted_on(self, platform):
        self.content_hosted_on = platform
        self.save()

#+END_SRC

***** setSimulationHostedOn: Experiment, HostingPlatform --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(platform=HostingPlatform)
    def set_simulation_hosted_on(self, platform):
        self.simulation_hosted_on = platform
        self.save()

#+END_SRC

***** addTechnology: Lab, Technology --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(technology=Technology)
    def add_technology(self, technology):
        self.technologies.append(technology)
        self.save()
#+END_SRC

***** removeTechnology: Lab, Technology --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(technology=Technology)
    def remove_technology(self, technology):
        if technology in self.technologies:
            self.technologies.remove(technology)
            self.save()
#+END_SRC

***** to_client
As JSON can't handle circular references, we cannot use =lab.to_client()= here
as it will fall into infinite recursion. Hence we just include the necessary
info about the lab.
#+BEGIN_SRC python :tangle src/db.py :eval no
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name,
            'content_url': self.content_url,
            'content_hosted_on': self.content_hosted_on.to_client() if\
                self.content_hosted_on else None,
            'simulation_url': self.simulation_url,
            'simulation_hosted_on': self.simulation_hosted_on.to_client() if\
                self.simulation_hosted_on else None,
            # as JSON can't handle circular references, we cannot do
            # lab.to_client() here as it will fall into infinite recursion
            'lab': {
                'id': self.lab.id,
                'lab_id': self.lab.lab_id,
                'name': self.lab.name
            }
        }

#+END_SRC

***** to_csv
#+BEGIN_SRC python :tangle src/db.py :eval no
    def to_csv(self):
        d = OrderedDict()
        d['lab_id'] = self.lab.lab_id
        d['name'] = self.name
        d['content_url'] = self.content_url
        d['content_hosted_on'] = self.content_hosted_on.name if\
            self.content_hosted_on else None
        d['simulation_url'] = self.simulation_url,
        d['simulation_hosted_on'] = self.simulation_hosted_on.name if\
            self.simulation_hosted_on else None
        return d
#+END_SRC

*** Lab
**** Immutable Data

     These are the data associated with Lab type, which are immutable.

     + Id
     + LabId

     As the number of experiments should be derived by the system from the
     experiments already associated with each lab.

**** Mutable Data
     These are the data associated with Lab type, which are mutable.

     + Name
     + Institute
     + Discipline
     + IntegrationLevel
     + HostedURL
     + RepoURL
     + TypeOfLab
     + HostedOn
     + Web2Compliant
     + Phase2Lab
     + Developer
     + Technology
     + Experiment
     + Remarks
     + Status

**** LabId assigned for each lab

     |-----------+--------------------------------------------------------------------------------------|
     | LabId     | Name                                                                                 |
     |-----------+--------------------------------------------------------------------------------------|
     | NULL      | Molecular biology Virtual Lab I                                                      |
     | NULL      | Biological Image processing Virtual Lab                                              |
     | NULL      | Ecology Virtual Lab                                                                  |
     | NULL      | Computer-Aided Drug Design Virtual Lab                                               |
     | NULL      | Systems Biology Virtual Lab                                                          |
     | NULL      | Bioinformatics Virtual Lab III                                                       |
     | NULL      | Bioinformatics Virtual Lab II                                                        |
     | NULL      | Solid State Physics Virtual Lab                                                      |
     | NULL      | Virtual Optics Lab                                                                   |
     | NULL      | Bioinformatics Virtual Lab I                                                         |
     | NULL      | Bio-inspired Robotics Virtual Lab (Remote Triggered)                                 |
     | NULL      | Virtual Biophysics Lab (Remote Triggered)                                            |
     | NULL      | Microbiology Virtual Lab II                                                          |
     | NULL      | Microbiology Virtual Lab I                                                           |
     | NULL      | Immunology Virtual Lab II                                                            |
     | NULL      | Immunology Virtual Lab I                                                             |
     | NULL      | Population Ecology Virtual Lab II                                                    |
     | NULL      | Population Ecology Virtual Lab I                                                     |
     | biotech01 | Biochemistry Virtual Lab I                                                           |
     | NULL      | Neuron Simulation Lab (pilot)                                                        |
     | NULL      | Neurophysiology (pilot)                                                              |
     | NULL      | Power Systems Lab                                                                    |
     | NULL      | Single Board Heater System                                                           |
     | NULL      | Microelectronics and VLSI Engineering                                                |
     | NULL      | Basic Electrical and Electronics Lab                                                 |
     | NULL      | Virtual High Voltage Lab                                                             |
     | NULL      | Chemical Process Dynamics                                                            |
     | NULL      | Mine Automation and Virtual Reality                                                  |
     | NULL      | Mechanical Systems and Signal Processing                                             |
     | NULL      | Condition Monitoring and Fault Simulation Lab                                        |
     | NULL      | Virtual Lab for Multiphase Flow                                                      |
     | NULL      | Robotics Simulation Lab                                                              |
     | NULL      | Mechanisms and Robotics Lab                                                          |
     | NULL      | Machinery Health Assessment Lab                                                      |
     | NULL      | Virtual Proteomics Laboratory                                                        |
     | NULL      | VLSI Design and Verification                                                         |
     | NULL      | Virtual and Remote Robotic and Mechatronic Laboratory                                |
     | NULL      | Virtual Circuits Laboratory                                                          |
     | NULL      | Electrical Machines, Power Electronics and Drives, Power Systems and Instrumentation |
     | NULL      | Structural Engineering Lab                                                           |
     | NULL      | Hydrodynamics and Transport phenomena in Packed Bed and Heat Exchangers              |
     | NULL      | Virtual Robotics Lab                                                                 |
     | NULL      | Virtual Lab for Mechanical Vibrations                                                |
     | NULL      | Model Based Fault Detection Lab                                                      |
     | NULL      | Molecular biology Virtual Lab II                                                     |
     | NULL      | Plant Metabolic Pathways Virtual Laboratory                                          |
     | NULL      | Internet Based Virtual CNC Lab                                                       |
     | NULL      | Advanced Communication                                                               |
     | NULL      | Laser Based Flow Diagnostics Laboratory                                              |
     | NULL      | Binary Distillation                                                                  |
     | NULL      | Thermal Processing and Microstructural Characterization                              |
     | NULL      | Mechanical Sciences - Liquid Crystal                                                 |
     | NULL      | Low Temp Electrical Transport and Property Measurements                              |
     | NULL      | Optical Device Characterizations                                                     |
     | NULL      | Aerospace Virtual laboratory                                                         |
     | NULL      | Control Systems/Magnetic Levitation System                                           |
     | NULL      | Mechanical Engineering Lab                                                           |
     | NULL      | Semiconductor Devices Laboratory                                                     |
     | NULL      | Information System Analysis and Design virtual Lab                                   |
     | NULL      | Advanced Pulse and Switching Lab                                                     |
     | NULL      | Substation Automation Lab                                                            |
     | NULL      | Ergonomics Lab for Assessing Physical Aspects of Design                              |
     | NULL      | Virtual Interactive Lab                                                              |
     | NULL      | Biomedical Instrumentation Lab                                                       |
     | NULL      | Virtual Pulse, Switching and Analogue Circuits                                       |
     | NULL      | Microelectronics Lab                                                                 |
     | NULL      | In-flight Particle History Lab                                                       |
     | NULL      | Manufacturing Laboratory                                                             |
     | NULL      | Virtual Physical Energy and Materials Science Lab                                    |
     | NULL      | Virtual Harmonic Motion and Waves Lab                                                |
     | NULL      | Virtual Modern Physics Lab                                                           |
     | NULL      | Virtual Heat and Thermodynamics Lab                                                  |
     | NULL      | Virtual Electricity and Magnetism Lab                                                |
     | NULL      | Laser Optics Virtual Lab                                                             |
     | NULL      | Virtual Advanced Mechanics Lab                                                       |
     | NULL      | Virtual Mechanics Lab/Nonlinear Dynamics                                             |
     | NULL      | Cell biology Virtual Lab II                                                          |
     | NULL      | Physical Chemistry(Amrita)                                                           |
     | NULL      | Organic Chemistry                                                                    |
     | NULL      | Virtual Combustion and Automation Laboratory                                         |
     | NULL      | Nanocomposite, Fabrication, Biomaterials and Signal Processing Laboratory            |
     | NULL      | Mechatronics Lab                                                                     |
     | NULL      | General Purpose Production Shop Simulation Lab                                       |
     | NULL      | Acoustics Virtual Lab                                                                |
     | NULL      | Advanced Geotechnical Lab                                                            |
     | NULL      | Virtual Wireless and Security                                                        |
     | NULL      | Electrochemistry                                                                     |
     | NULL      | Inorganic Chemistry                                                                  |
     | NULL      | Cell biology Virtual Lab I                                                           |
     | NULL      | Kinematics and Dynamics of Mechanisms                                                |
     | NULL      | Real Time Embedded Systems Laboratory                                                |
     | NULL      | Satellite Modelling and Simulation                                                   |
     | ece29     | Remote Triggered Fiber Optics Communication Lab                                      |
     | NULL      | Electro Mechanical Conversion                                                        |
     | NULL      | Technology CAD (TCAD) Laboratory                                                     |
     | NULL      | Fading Channels and Mobile Communications                                            |
     | NULL      | Soft Computing Tools in Engineering                                                  |
     | NULL      | Analog Signals, Network and Measurement Laboratory                                   |
     | biotech02 | Biochemistry Virtual Lab II                                                          |
     | ae01      | Aerospace Structures Lab                                                             |
     | bio15     | Bio-reactor Modeling and Simulation Lab                                              |
     | bio16     | Biomedical and Signal Processing Laboratory                                          |
     | ccnsb01   | Molecular Fluorescence Spectroscopy                                                  |
     | ccnsb02   | Colloid and Surface Chemistry                                                        |
     | ccnsb03   | Molecular Absorption Spectroscopy                                                    |
     | ccnsb04   | Quantum Chemistry                                                                    |
     | ccnsb05   | Circular Dichroism Spectroscopy                                                      |
     | ccnsb06   | Physical Chemistry (IIIT-H)                                                          |
     | ccnsb07   | Molecular Interactions                                                               |
     | che02     | Virtual Lab for Mass Transfer                                                        |
     | chem01    | Chemical Engineering                                                                 |
     | chem05    | Unit Operations, Reaction Engineering and Process Control                            |
     | chs12     | Virtual Chemistry Lab                                                                |
     | chs13     | Ultrafast Laser Spectroscopy                                                         |
     | chs14     | Analytical Lab                                                                       |
     | civil07   | Strength of Materials and Fluid Mechanics                                            |
     | civil09   | Traffic Engineering                                                                  |
     | civil11   | Virtual Satellite Image Processing and Analysis                                      |
     | civil13   | Urban Transportation Systems Planning                                                |
     | civil15   | Surveying Lab                                                                        |
     | civil16   | Virtual Smart Structures and Dynamics Lab                                            |
     | cse01     | Data Structures                                                                      |
     | cse02     | Computer Programming                                                                 |
     | cse03     | Programming and Data Structure                                                       |
     | cse04     | Problem Solving                                                                      |
     | cse05     | Principles of Programming Languages                                                  |
     | cse06     | Data Mining                                                                          |
     | cse07     | Databases                                                                            |
     | cse08     | Software Engineering                                                                 |
     | cse09     | Linux Lab                                                                            |
     | cse10     | Computer Architecture and Organization                                               |
     | cse11     | Computer Organization                                                                |
     | cse12     | FPGA and Embedded System Lab                                                         |
     | cse13     | Advanced VLSI                                                                        |
     | cse14     | VLSI                                                                                 |
     | cse15     | Digital Logic Design                                                                 |
     | cse16     | Speech Signal Processing (IIIT-H)                                                    |
     | cse17     | Mobile Robotics                                                                      |
     | cse18     | Computer Graphics                                                                    |
     | cse19     | Image Processing                                                                     |
     | cse20     | Pattern Recognition                                                                  |
     | cse21     | Optical Remote Sensing                                                               |
     | cse22     | Artificial Neural Networks                                                           |
     | cse23     | Computational Linguistics                                                            |
     | cse24     | Natural Language Processing                                                          |
     | cse25     | Wireless Sensor Networks                                                             |
     | cse26     | Network Security                                                                     |
     | cse28     | Advanced Network Technologies                                                        |
     | cse29     | Cryptography                                                                         |
     | cse30     | Analog CMOS VLSI Circuit Design                                                      |
     | ece01     | Speech Signal Processing (IIT-G)                                                     |
     | ece02     | Electro Magnetic Transmission (Virtual MEMS Lab)                                     |
     | ece03     | Transducer and Instrumentation Virtual Lab                                           |
     | ece04     | Electronic design using DSP, FPGA, CPLD and Micro Controllers                        |
     | ece05     | Digital VLSI Design Virtual Lab                                                      |
     | ece06     | Digital Signal Processing Lab                                                        |
     | ece07     | Digital Electronics Circuit Lab                                                      |
     | ece08     | Engineering Electromagnetic Lab                                                      |
     | ece09     | Wireless Lab                                                                         |
     | ece10     | Signals and Systems Laboratory                                                       |
     | ece11     | Systems, Communication and Control Laboratory                                        |
     | ece18     | RF Microwave Characterization Lab                                                    |
     | ece19     | Hybrid Electronics                                                                   |
     | ece21     | Virtual Queuing Networks Modelling                                                   |
     | ece22     | Virtual Microwave and Antenna Lab                                                    |
     | ece23     | Digital Electronics                                                                  |
     | ece26     | Virtual Advanced Lab for Interactive Design and Test in Electronics                  |
     | ece28     | FPGA and Digital Design                                                              |
     | eee01     | Power Electronics                                                                    |
     | eee02     | Electrical Machines Laboratory                                                       |
     | eee03     | Electronic Instrumentation                                                           |
     | eee05     | Sensors Modeling and Simulation                                                      |
     | eee06     | Virtual Power Laboratory                                                             |
     | eee07     | Virtual Power Electronics and Electric Drives Lab                                    |
     | eee08     | Industrial Electric Drives and Application of PLC                                    |
     | eee09     | Industrial Automation Laboratory                                                     |
     | eee10     | Electrical Machines                                                                  |
     | eee12     | PLC                                                                                  |
     | eee23     | Biomedical Signal and Image Processing                                               |
     | eee24     | Machine Lab                                                                          |
     | eerc01    | Basic Engineering Mechanics and Strength of Materials                                |
     | eerc02    | Soil Mechanics                                                                       |
     | eerc03    | Hydraulics and Fluid Mechanics                                                       |
     | eerc04    | Basic Structural Analysis                                                            |
     | eerc05    | Geotechnical Engineering Lab                                                         |
     | eerc06    | Structural Dynamics                                                                  |
     | emt       | Electro Magnetic Theory                                                              |
     | hss01     | Creative Design, Prototyping and Experiential Simulation Lab                         |
     | hss02     | Virtual English and Communication Lab                                                |
     | hss03     | Virtual Anthropology Lab                                                             |
     | mech01    | Virtual Laboratory Experience in Fluid and Thermal Sciences                          |
     | mech04    | Vibration and Acoustics Lab                                                          |
     | mech05    | Mechanics of Machine                                                                 |
     | mech08    | Material Response to Microstructural, Mechanical, Thermal and Biological Stimuli     |
     | mech17    | Micromachining Laboratory                                                            |
     | mech18    | Fab Laboratory                                                                       |
     | mech21    | Machine Dynamics and Mechanical Vibrations                                           |
     | mech26    | Metal Forming and Solid Mechanics                                                    |
     | phy01     | Virtual Astrophysics Lab                                                             |
     | phy12     | Virtual Microwave Laboratory                                                         |
     | phy14     | Physical Sciences                                                                    |
     | phy19     | Virtual Laboratory on Oscillations                                                   |
     | txtl01    | Carpet Analysis                                                                      |
     | txtl02    | Electrical Conductivity                                                              |
     | txtl03    | SEM Central Facility                                                                 |
     |-----------+--------------------------------------------------------------------------------------|

**** Association
#+BEGIN_SRC python :tangle src/db.py :eval no
# association table of developers and labs
developers_engaged = db.Table(
    'developers_engaged',
    db.Column('lab_id', db.Integer, db.ForeignKey('labs.id')),
    db.Column('developer_id', db.Integer, db.ForeignKey('developers.id'))
)

 # association table of technologies and labs
technologies_used_labs = db.Table(
    'technologies_used_labs',
    db.Column('lab_id', db.Integer, db.ForeignKey('labs.id')),
    db.Column('tech_id', db.Integer, db.ForeignKey('technologies.id'))
)

#+END_SRC
**** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Lab(Entity):

    __tablename__ = 'labs'

    id = db.Column(db.Integer, primary_key=True)

    name = db.Column(db.String(128), nullable=False)

    lab_id = db.Column(db.String(16), nullable=False)

    institute_id = db.Column(db.Integer, db.ForeignKey('institutes.id'))

    discipline_id = db.Column(db.Integer, db.ForeignKey('disciplines.id'))

    integration_level_id = db.Column(db.ForeignKey('integration_levels.id'))

    developers = db.relationship('Developer', secondary=developers_engaged,
                                 backref='labs')

    number_of_experiments = db.Column(db.Integer)

    experiments = db.relationship('Experiment', backref='lab')

    technologies = db.relationship('Technology',
                                   secondary=technologies_used_labs,
                                   backref='labs')

    repo_url = db.Column(db.String(256))

    hosted_url = db.Column(db.String(256))

    hosted_on_id = db.Column(db.ForeignKey('hosting_platforms.id'))

    type_of_lab_id = db.Column(db.ForeignKey('type_of_labs.id'))

    remarks = db.Column(db.Text)

    status = db.Column(db.String(32))

    is_web_2_compliant_lab = db.Column(db.Boolean)

    is_phase_2_lab = db.Column(db.Boolean)
#+END_SRC

**** Constructor for Lab
Signature of the constructor for Lab is as follows. Attributes inside [...]
are optional when constructing the lab. Other attributes are mandatory.

Experiments are never a part of the constructor. That is experiemtns are not
associated with a lab when the lab is being created. That would mean the
experiments existed before the lab existed independently, which is not the
case in reality. Hence a lab is created first, and then experiments are
created and associated with an existing lab. So, experiments are never a part
of Lab constructor.
#+BEGIN_EXAMPLE python
Lab(name=<instance of Name class>,
    lab_id=String
    [,institute=<instance of Institute class>]
    [,discipline=<instance of Discipline class>]
    [,integration_level=<instance of IntegrationLevel class>]
    [,developers=<list of instance of Developer class>]
    [,technologies=<list of instance of Technology class>]
    [,repo_url=<instance of URL class>]
    [,hosted_url=<instance of URL class>]
    [,hosted_on=<instance of HostingPlatform class>]
    [,type_of_lab=<instance of TypeOfLab class>]
    [,is_web_2_compliant_lab=Boolean]
    [,is_phase_2_lab=Boolean])
#+END_EXAMPLE

#+BEGIN_SRC python :tangle src/db.py :eval no
    def __init__(self, **kwargs):

        if 'lab_id' not in kwargs:
            raise AttributeRequired('`lab_id` attribute is required when '
                                    'initializaing a Lab')
        self.lab_id = kwargs['lab_id']

        if 'name' not in kwargs:
            raise AttributeRequired('`name` atttribute is required when '
                                    'initializaing a Lab')
            raise TypeError('`name` attribute should be of type "str"')
        self.set_name(kwargs['name'])

        if 'institute' in kwargs:
            self.set_institute(kwargs['institute'])

        if 'discipline' in kwargs:
            self.set_discipline(kwargs['discipline'])

        if 'integration_level' in kwargs:
            self.set_integration_level(kwargs['integration_level'])

        if 'type_of_lab' in kwargs:
            self.set_type_of_lab(kwargs['type_of_lab'])

        if 'hosted_on' in kwargs:
            self.set_hosted_on(kwargs['hosted_on'])

        if 'repo_url' in kwargs:
            self.set_repo_url(kwargs['repo_url'])

        if 'hosted_url' in kwargs:
            self.set_hosted_url(kwargs['hosted_url'])

        if 'is_web_2_compliant_lab' in kwargs:
            self.set_is_web_2_compliant_lab(kwargs['is_web_2_compliant_lab'])

        if 'is_phase_2_lab' in kwargs:
            self.set_is_phase_2_lab(kwargs['is_phase_2_lab'])

        if 'remarks' in kwargs:
            self.set_remarks(kwargs['remarks'])

        if 'status' in kwargs:
            self.set_status(kwargs['status'])

        if 'developers' in kwargs:
            if not isinstance(kwargs['developers'], list):
                raise TypeError('`developers` attribute should be of list '
                                'type. Each item being of Developer class')
            for developer in kwargs['developers']:
                self.add_developer(developer)

        if 'technologies' in kwargs:
            if not isinstance(kwargs['technologies'], list):
                raise TypeError('`technologies` attribute should be of '
                                'list type. Each item being of Technology '
                                'class')
            for technology in kwargs['technologies']:
                self.add_technology(technology)

#+END_SRC

**** Functions that operate on the Lab domain

***** update: Lab --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    # update the object, and commit to the database
    def update(self, **kwargs):

        for attr, val in kwargs.iteritems():
            # if the attr is any of the following the setter method names are
            # not straightforward. And then directly assign the given list to
            # the attribute
            if attr in ('developers', 'experiments', 'technologies'):
                self.__setattr__(attr, val)

            # else it is a attribute where the setter method name matches!
            else:
                setter_method = "set_" + attr
                try:
                    self.__getattribute__(setter_method)(val)
                except Exception as e:
                    raise e

        self.save()
        # the below code is for historical reasons. the below is the
        # implementation done using setters. the implementation is so complex
        # that we decided not to use it, and directly set the attribute.
            # if the attr is any of the following, get the setter method from
            # the dictionary below, as the setter method names are not
            # straightforward
            #setter_methods = {'developers': 'developer',
            #                  'experiments': 'experiment',
            #                  'technologies': 'technology'}
            #if attr in ('developers', 'experiments', 'technologies'):
                #print "spl attr: %s" % attr
                ## the val will be a list in this case; iterate over the list
                ## check if each item is present in the list; if not add it.
                #for item in val:
                #    if item not in self.__getattribute__('get_'+attr)():
                #        print "new val in %s: %s" % (attr, item)
                #        setter_method = 'add_' + setter_methods[attr]
                #        try:
                #            self.__getattribute__(setter_method)(item)
                #        except Exception as e:
                #            raise e

                ## now check all the items from existing field with the request
                ## recvd. If any item is extra in the existing field (which is
                ## not there in the req), delete it
                #for item in self.__getattribute__('get_'+attr)():
                #    # the item exist in the existing field, but not in the
                #    # req.; remove it.
                #    if item not in val:
                #        print "item do not exist %s: %s" % (attr, item)
                #        setter_method = 'remove_' + setter_methods[attr]
                #        try:
                #            self.__getattribute__(setter_method)(item)
                #        except Exception as e:
                #            raise e
#+END_SRC

***** getId: Lab --> Id
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_id(self):
        return self.id

#+END_SRC

***** getLab: Id --> Lab
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_by_id(id):
        return Lab.query.get(id)
#+END_SRC

***** getAll: Nil --> set[Lab]
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_all(fields=None):
        # get all labs from db
        labs = Lab.query.all()
        print 'total count of labs'
        print len(labs)
        # print fields
        # if request do not contain fields, return the data
        if not fields:
            return labs
        # if fields exist in the request, format all the labs to have only the
        # fields requested by the user
        formatted_labs = Lab.format_labs_by_fields(labs, fields)
        return formatted_labs
#+END_SRC

***** getLabId: Lab --> LabId
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_lab_id(self):
        return self.lab_id
#+END_SRC

***** getLab: LabId --> Lab
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_by_lab_id(lab_id):
        return Lab.query.filter_by(lab_id=lab_id).first()
#+END_SRC

***** getName: Lab --> Name

This is similar to the =getId= function and all types will have this
function.
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_name(self):
        return self.name
#+END_SRC

***** getIntegrationLevel: Lab --> Level
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_integration_level(self):
        return self.integration_level.level
#+END_SRC

***** isHosted: Lab --> Boolean
#+BEGIN_SRC python :tangle src/db.py :eval no
    def is_hosted(self):
        if self.hosted_url:
            return True
        return False
#+END_SRC

***** getHostedURL: Lab --> Nil + URL

       URL: when hosted

       Nil: when not hosted
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_hosted_url(self):
        return self.hosted_url
#+END_SRC

***** isSourceAvailable: Lab --> Boolean
#+BEGIN_SRC python :tangle src/db.py :eval no
    def is_source_available(self):
        if self.repo_url:
            return True
        return False
#+END_SRC

***** getRepoURL: Lab --> Nil + URL

       URL: when sources are available

       Nil: otherwise
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_repo_url(self):
        return self.repo_url
#+END_SRC

***** getType: Lab --> TypeOfLab
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_type(self):
        return self.type_of_lab
#+END_SRC

***** getNoOfExperiments: Lab --> Nat
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_num_of_experiments(self):
        return len(self.experiments)
#+END_SRC

***** getHostedOn: Lab --> HostingPlatform + Nil
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_hosted_on(self):
        return self.hosted_on
#+END_SRC

***** isWeb2Compliant: Lab --> Boolean
#+BEGIN_SRC python :tangle src/db.py :eval no
    def is_web_2_compliant(self):
        return self.is_web_2_compliant_lab
#+END_SRC

***** isPhase2Lab: Lab --> Boolean
#+BEGIN_SRC python :tangle src/db.py :eval no
    def is_phase_2(self):
        return self.is_phase_2_lab
#+END_SRC

***** getDiscipline: Lab --> Discipline
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_discipline(self):
        return self.discipline
#+END_SRC

***** getExperiments: Lab --> set[Experiment]
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_experiments(self):
        return self.experiments
#+END_SRC

***** getInstitute: Lab --> Institute
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_institute(self):
        return self.institute
#+END_SRC

***** getDevelopers: Lab --> set[Developer]
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_developers(self):
        return self.developers
#+END_SRC

***** getTechnologies: Lab --> set[Technology]
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_technologies(self):
        return self.technologies
#+END_SRC

***** getRemarks: Lab --> Remarks

#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_remarks(self):
        return self.remarks
#+END_SRC
***** getStatus: Lab --> Status

#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_status(self):
        return self.status
#+END_SRC

***** setName: Lab, Name --> Void

       NOTE: All types will have a =setName= function.
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(name=str)
    def set_name(self, name):
        self.name = name
        self.save()
#+END_SRC

***** setInstitute: Lab, Institute --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(institute=Institute)
    def set_institute(self, institute):
        self.institute = institute
        self.save()
#+END_SRC

***** setDiscipline: Lab, Discipline --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(discipline=Discipline)
    def set_discipline(self, discipline):
        self.discipline = discipline
        self.save()
#+END_SRC

***** setIntegrationLevel: Lab, Level --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(level=IntegrationLevel)
    def set_integration_level(self, level):
        self.integration_level = level
        self.save()
#+END_SRC

***** setHostedURL: Lab, URL --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(url=URL)
    def set_hosted_url(self, url):
        self.hosted_url = url.value
        self.save()
#+END_SRC

***** setRepoURL: Lab, URL --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(url=URL)
    def set_repo_url(self, url):
        self.repo_url = url.value
        self.save()
#+END_SRC

***** setTypeOfLab: Lab, TypeOfLab --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(type=TypeOfLab)
    def set_type_of_lab(self, type):
        self.type_of_lab = type
        self.save()
#+END_SRC

***** setHostedOn: Lab, HostingPlatform --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(platform=HostingPlatform)
    def set_hosted_on(self, platform):
        self.hosted_on = platform
        self.save()
#+END_SRC

***** setWeb2Compliant: Lab, Boolean --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(compliant=bool)
    def set_is_web_2_compliant_lab(self, compliant):
        self.is_web_2_compliant_lab = compliant
        self.save()
#+END_SRC

***** setIsPhase2: Lab, Boolean --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(phase2=bool)
    def set_is_phase_2_lab(self, phase2):
        self.is_phase_2_lab = phase2
        self.save()
#+END_SRC
***** setRemarks: Lab, String --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(remarks=str)
    def set_remarks(self, remarks):
        self.remarks = remarks
        self.save()
#+END_SRC
***** setStatus: Lab, String --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(status=str)
    def set_status(self, status):
        self.status = status
        self.save()
#+END_SRC


***** addDeveloper: Lab, Developer --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(developer=Developer)
    def add_developer(self, developer):
        self.developers.append(developer)
        self.save()
#+END_SRC

***** removeDeveloper: Lab, Developer --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(developer=Developer)
    def remove_developer(self, developer):
        if developer in self.developers:
            self.developers.remove(developer)
            self.save()
#+END_SRC

***** addTechnology: Lab, Technology --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(technology=Technology)
    def add_technology(self, technology):
        self.technologies.append(technology)
        self.save()
#+END_SRC

***** removeTechnology: Lab, Technology --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(technology=Technology)
    def remove_technology(self, technology):
        if technology in self.technologies:
            self.technologies.remove(technology)
            self.save()
#+END_SRC

***** addExperiment: Lab, Experiment --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(experiment=Experiment)
    def add_experiment(self, experiment):
        self.experiments.append(experiment)
        self.save()
#+END_SRC

***** removeExperiment: Lab, Experiment --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(experiment=Experiment)
    def remove_experiment(self, experiment):
        if experiment in self.experiments:
            self.experiments.remove(experiment)
            self.save()
#+END_SRC

***** formatLabsByFields
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def format_labs_by_fields(labs, fields):
        current_app.logger.debug("labs recvd: %s" % labs)
        formatted_labs = []  # all labs
        for lab in labs:
            formatted_lab = {}  # formatted lab
            for field in fields:
                try:
                    formatted_lab[field] = lab[field]
                except KeyError:
                    raise Exception('Invalid field %s', field)

            # print fmttd_lab
            formatted_labs.append(formatted_lab)
        return formatted_labs
#+END_SRC

***** to_client
#+BEGIN_SRC python :tangle src/db.py :eval no
    def to_client(self):
        return {
            'id': self.id,
            'lab_id': self.lab_id,
            'name': self.name,
            'institute': self.institute.to_client() if self.institute else None,
            'discipline': self.discipline.to_client() if self.discipline else\
                None,
            'integration_level': self.integration_level.to_client() if\
                self.integration_level else None,
            'repo_url': self.repo_url,
            'hosted_url': self.hosted_url,
            'hosted_on': self.hosted_on.to_client() if self.hosted_on else\
                None,
            'technologies': [t.to_client() for t in self.get_technologies()] if\
                self.technologies else None,
            'experiments': [e.to_client() for e in self.get_experiments()] if\
                self.experiments else None,
            'developers': [d.to_client() for d in self.get_developers()] if\
                self.developers else None,
            'type_of_lab': self.type_of_lab.to_client() if self.type_of_lab
                else None,
            'status': self.status,
            'is_web_2_compliant': self.is_web_2_compliant(),
            'is_phase_2_lab': self.is_phase_2(),
            'remarks': self.remarks
        }
#+END_SRC

***** to_csv
#+BEGIN_SRC python :tangle src/db.py :eval no
    def to_csv(self):
        d = OrderedDict()
        d['lab_id'] =  self.lab_id
        d['name'] =  self.name
        d['institute_id'] = self.institute.institute_id
        d['discipline_id'] = self.discipline.discipline_id
        d['integration_level'] = self.integration_level.level if\
            self.integration_level else None
        d['repo_url'] =  self.repo_url
        d['hosted_url'] = self.hosted_url
        d['hosted_on'] = self.hosted_on.name if self.hosted_on else None
        d['type_of_lab'] = self.type_of_lab.type if self.type_of_lab else None
        d['status'] = self.status
        d['is_web_2_compliant'] = self.is_web_2_compliant_lab
        d['is_phase_2'] = self.is_phase_2_lab
        d['remarks'] = self.remarks
        return d
#+END_SRC

*** Feedback data
**** Immutable data
     + Id
     + time
     + IP address
     + User Name
     + User Email
     + User Institute
     + User Discipline
     + Feedback data
**** Mutable data
None of the feedback data is mutable. Once entered into the system, it
can only be read.
**** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Feedback(Entity):

    __tablename__ = 'feedback_data'

    id = db.Column(db.Integer, primary_key=True)

    lab_id = db.Column(db.Integer, db.ForeignKey('labs.id'))
    lab = db.relationship('Lab')

    experiment_id = db.Column(db.Integer, db.ForeignKey('experiments.id'))
    experiment = db.relationship('Experiment')

    user_name = db.Column(db.String(64))
    user_email = db.Column(db.String(64))

    user_institute = db.Column(db.String(64))
    user_discipline = db.Column(db.String(64))

    time = db.Column(db.DateTime, default=datetime.utcnow)
    ip = db.Column(db.String(16))

    #data = db.Column(JSONType)
    type_of_user = db.Column(db.String(32))
    experiment_attempted = db.Column(db.Boolean)
    experiment_works = db.Column(db.Boolean)
    if_no_what_issue = db.Column(db.Text)
    problem_while_performing_experiment = db.Column(db.Text)
    most_interesting_things = db.Column(db.Text)
    why_how_plan_to_use_vlabs = db.Column(db.Text)
    suggestions = db.Column(db.Text)
#+END_SRC
**** Constructor
     Signature of the constructor is as follows. Attributes inside [...]  are
     optional. Others are mandatory.
#+BEGIN_EXAMPLE python
    feedback = Feedback(lab=<instance of Lab>
                        [,experiment=<instance of Experiment>]
                        [,user_name=<instance of Name>]
                        [,user_email=<instance of Email>]
                        [,user_institute=<str>]
                        [,user_discipline=<str>]
                        [,ip=<str>]
                        [,type_of_user=<str>]
                        [,experiment_attempted=<bool>]
                        [,experiment_works=<bool>]
                        [,if_no_what_issue=<str>]
                        [,problem_while_performing_experiment=<str>]
                        [,most_interesting_things=<str>]
                        [,why_how_plan_to_use_vlabs=<str>]
                        [,suggestions=<str>])
#+END_EXAMPLE

#+BEGIN_SRC python :tangle src/db.py :eval no
    def __init__(self, **kwargs):
        if 'lab' not in kwargs:
            raise AttributeRequired("`lab` attribute is required.")

        if not isinstance(kwargs['lab'], Lab):
            raise TypeError("`lab` should be an instance of class Lab")
        self.lab = kwargs['lab']

        if 'experiment' in kwargs:
            if not isinstance(kwargs['experiment'], Experiment):
                raise TypeError("`experiment` should be an instance of class Experiment")
            self.experiment = kwargs['experiment']

        if 'user_name' in kwargs:
            if not isinstance(kwargs['user_name'], Name):
                raise TypeError("user_name should be of type Name")
            self.user_name = kwargs['user_name'].value

        if 'user_email' in kwargs:
            if not isinstance(kwargs['user_email'], Email):
                raise TypeError("user_email should be of type Email")
            self.user_email = kwargs['user_email'].value

        if 'user_institute' in kwargs:
            if not isinstance(kwargs['user_institute'], str):
                raise TypeError("user_institute should be of type str")
            self.user_institute = kwargs['user_institute']

        if 'user_discipline' in kwargs:
            if not isinstance(kwargs['user_discipline'], str):
                raise TypeError("user_discipline should be of type str")
            self.user_discipline = kwargs['user_discipline']

        if 'ip' in kwargs:
            if not isinstance(kwargs['ip'], str):
                raise TypeError("ip should be of type str")
            self.ip = kwargs['ip']

        if 'type_of_user' in kwargs:
            if not isinstance(kwargs['type_of_user'], str):
                raise TypeError("type_of_user should be of type str")
            self.type_of_user = kwargs['type_of_user']

        if 'experiment_attempted' in kwargs:
            if not isinstance(kwargs['experiment_attempted'], bool):
                raise TypeError("experiment_attempted should be of type bool")
            self.experiment_attempted = kwargs['experiment_attempted']

        if 'experiment_works' in kwargs:
            if not isinstance(kwargs['experiment_works'], bool):
                raise TypeError("experiment_works should be of type bool")
            self.experiment_works = kwargs['experiment_works']

        if 'if_no_what_issue' in kwargs:
            if not isinstance(kwargs['if_no_what_issue'], str):
                raise TypeError("if_no_what_issue should be of type str")
            self.if_no_what_issue = kwargs['if_no_what_issue']

        if 'most_interesting_things' in kwargs:
            if not isinstance(kwargs['most_interesting_things'], str):
                raise TypeError("most_interesting_things should be of type str")
            self.most_interesting_things = kwargs['most_interesting_things']

        if 'problem_while_performing_experiment' in kwargs:
            if not isinstance(kwargs['problem_while_performing_experiment'], str):
                raise TypeError("problem_while_performing_experiment should be of type str")
            self.problem_while_performing_experiment = kwargs['problem_while_performing_experiment']

        if 'why_how_plan_to_use_vlabs' in kwargs:
            if not isinstance(kwargs['why_how_plan_to_use_vlabs'], str):
                raise TypeError("why_how_plan_to_use_vlabs should be of type str")
            self.why_how_plan_to_use_vlabs = kwargs['why_how_plan_to_use_vlabs']

        if 'suggestions' in kwargs:
            if not isinstance(kwargs['suggestions'], str):
                raise TypeError("suggestions should be of type str")
            self.suggestions = kwargs['suggestions']


#+END_SRC
**** Functions that operate on the Feedback domain
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_all():
        return Feedback.query.all()

    @staticmethod
    def get_by_id(id):
        return Feedback.query.get(id)

    def update(self, **kwargs):
        raise Exception('Feedback data cannot be updated')

    def delete(self):
        raise Exception('Feedback data cannot be deleted')

    def to_client(self):
        return {
            'id': self.id,
            'lab': {
                'id': self.lab.id,
                'lab_id': self.lab.lab_id,
                'name': self.lab.name
            },
            'experiment': self.experiment.to_client() if self.experiment\
                else None,
            'user_name': self.user_name,
            'user_email': self.user_email,
            'user_institute': self.user_institute,
            'user_discipline': self.user_discipline,
            'ip': self.ip,
            'time': self.time.isoformat(),
            'type_of_user': self.type_of_user,
            'experiment_works': self.experiment_works,
            'experiment_attempted': self.experiment_attempted,
            'if_no_what_issue': self.if_no_what_issue,
            'problem_while_performing_experiment':\
                self.problem_while_performing_experiment,
            'most_interesting_things': self.most_interesting_things,
            'why_how_plan_to_use_vlabs': self.why_how_plan_to_use_vlabs,
            'suggestions': self.suggestions
        }
#+END_SRC

*** COMMENT Functions operating on multiple domains

***** NOTE: is it necessary? getAllLabs: Nil --> set[Lab]

***** NOTE: is it necessary? getAllDevelopers: Nil --> set[Developer]

***** NOTE: is it necessary? getAllExperiments: Nil --> set[Experiment]


*** COMMENT Relationship between different entities
  #+CAPTION: Entity Diagram
  #+NAME:   entity
  [[https://drive.google.com/open?id%3D0B6LLRcwXMzt8N3RzZGVkb0NpUDA][ER-Diagram]]

** COMMENT The Bulk Update interface
*** Requirement
   One of the requirements in the application is the bulk update
   interface. <<req4>>
   A bulk update interface is such an interface of the application (or a
   capability of the application) which can support updating multiple records
   of the data at once.

*** Design decisions
   The decision is to have this interface in terms of a spreadsheet
   file. The user downloads the spreadsheet file, edits/adds new
   entries and then uploads the spreadsheet file, and then the
   application reads the spreadsheet file and performs bulk update.

   The rationale for using a spreadsheet interface is - providing a
   bulk update *web* interface is more expensive in terms of development
   effort and learning effort of the user.

   The design decision is to use a CSV file instead of some
   spreadsheet file format as the data format with the interface for
   bulk updates. This is because CSV files can be imported/exported to
   a spreadsheet programs as well as a database. Otherwise one has to
   handle a plethora of spreadsheet file formats, which can become
   very expensive to implement.

*** High-level Design
   There are two parts to the bulk update interface:
   1. One part of the interface let users download a template CSV file
      to populate the data. If data already exist in the system, the
      downloaded CSV file contains all the current data in the
      system. The users can then edit, modify or insert new data.

   2. The second part of the interface is where the user can upload
      the CSV file. Once the user uploads the CSV file, the system
      then reads the CSV file, uses the internal Python API to check
      for sanity, integrity constraints etc. and use the Python API to
      insert the data into the system

**** Authentication and authorization
     Access to =/data/download= and =/data/upload= APIs are restricted by IP
     restriction and CORS policy so only authorized applications can call
     these APIs. This will prevent anyone in the world from accessing this
     APIs. The next part is, given, an authorized application how does the
     data service validate the authorized application is used by an authorized
     user. For this we need to implement a user login. Which is the same way
     as it is done in
     ADS.


*** Technical Design
    To download the data the Python API has to return a CSV of the
    entire database. Now CSV dump of the entire database can be made
    but it is impractical, as the entire dataset will be in one CSV
    file. This will have the overhead of first splitting the CSV file
    into multiple CSV files and then importing them to a spreadsheet
    application; editing them and then putting them back to a single
    CSV file for upload. And even when the Python API can put all the
    tables together into one CSV file, but while parsing the data to
    update, it has to do some string manipulations to figure out where
    the data for the first table ends and second table begins. This
    not desired. Hence the straight-forward, simple and elegant
    solution seems to be that each entity (or table) will have its own
    CSV file, which will be downloaded, edited and then uploaded back
    again. One has to do the same for each entity. There will be a
    list of valid entities. This list is same as the look up table of
    the REST APIs, described below.

    Hence the actual implementation will consist of:
    1. one static page to (the static page talks to the below REST APIs):
       1. select and download data of a particular entity. The downloaded
	  file is a CSV.
       2. select and upload data of a particular entity. The uploaded
	  file is a CSV.
    2. one REST API to actually provide the download:
       =/data/download?entity=<entity-name>=
       Example:
       =/data/download?entity=labs=
       =/data/download?entity=institutes=
    3. one REST API to take the uploaded CSV data and perform the
       update:
       =/data/upload?entity=<entity-name>=
       Example:
       =/data/upload?entity=labs=
       =/data/upload?entity=institutes=

*** Implementation

#+NAME: bulk-update-interface
#+BEGIN_SRC python :eval no :exports none

bulk_update_allowed = {
    'labs': Lab,
    'institutes': Institute,
    'experiments': Experiment,
    'disciplines': Discipline,
    'developers': Developer,
    'technologies': Technology
}

CUR_DIR = os.path.dirname(os.path.realpath(__file__))

@api.route('/data/download')
def download_data():
    entity = request.args.get('entity', None)
    if not entity:
        abort(400, 'Entity has to be provided in the request')

    if entity and entity not in bulk_update_allowed:
        abort(400, 'Entity %s is not valid' % entity)

    curr_entity = bulk_update_allowed[entity]
    data = curr_entity.query.all()

    if not len(data):
        abort(400, "No data for %s found!" % entity)

    # open the CSV file for writing
    filename = entity + '.csv'
    outfile = open(os.path.join(CUR_DIR, 'static', 'temp', filename),
                  'wb')
    outcsv = csv.writer(outfile)

    # write the data..
    outcsv.writerow(data[0].to_csv().keys())
    [outcsv.writerow(curr.to_csv().values()) for curr in data]
    outfile.close()

    # return URL of the file for download
    return redirect(url_for('static', filename='temp/'+filename))


def allowed_file(filename):
    return '.' in filename and \
               filename.rsplit('.', 1)[1] in \
               current_app.config.ALLOWED_EXTENSIONS


@api.route('/data/upload', methods=['POST'])
def upload_data():
    entity = request.args.get('entity', None)
    if not entity:
        abort(400, 'Entity has to be provided in the request')

    if entity and entity not in bulk_update_allowed:
        abort(400, 'Entity %s is not valid' % entity)

    file = request.files['file']
    if file and allowed_file(file.filename):
        reader = csv.reader(file, delimiter=',')
        fields = reader.next()
        data = []
        map(lambda row: data.append(dict(zip(fields, row))), reader)
        return jsonify_list(data)

@api.route('/data')
def show_static_data_page():
    return '''
    <!doctype html>
    <title>Data Service - bulk update</title>
    <h1>Upload new File</h1>
    <script type="text/javascript">
        function submitform() {
            var elem = document.getElementById('entity');
            var entity = elem.options[elem.selectedIndex].value;
            document.myform.action = "/data/upload?entity=" + entity;
            return true;
        }
    </script>
    <select id="entity">
        <option value="labs">Labs</option>
        <option value="institutes">Institutes</option>
        <option value="disciplines">Disciplines</option>
        <option value="developers">Developers</option>
        <option value="technologies">Technologies</option>
        <option value="experiments">Experiments</option>
    </select>
    <form name="myform" method=post enctype=multipart/form-data onsubmit="return submitform();">
    <p><input type=file name=file>
    <input type=submit value=Upload>
    </form>
    '''

#+END_SRC

** REST APIs
*** What are REST APIs?
   REST APIs are the interface of the data service with which the
   external world interacts. This interface is over HTTP. So, we
   expose and publish a set of HTTP URLs. With appropriate HTTP
   methods and the correct URL, various operations on various entities
   can be performed, by making the corresponding request.

*** Design
   A different approach is taken here in designing the REST
   APIs. Instead of writing specific REST APIs for each operation on
   each entity, we designed some generic RESTful URL endpoints(APIs)
   to capture all kinds of operations(read, query, update, delete) on
   any existing entity in the system.

   This is achieved by having look up table(s) or map(s) which
   contains some keyword mapped to existing entities in the system,
   and maybe some other additional data.

   This design makes adding of a new entity relatively simple. Once we
   add a new entity, and design its Python API, to expose the entity
   over REST APIs, we just have to modify the look up table.

   Generic patterns of URL, and examples of look up table(s) are
   discussed below.

   **TODO**: usage documentation of all REST APIs for the consumers of data
   service has to be written down somewhere and published.

*** Some code..
   The Python code to have the imports, boilerplate code etc. for the
   APIs.  We are using Flask blueprints to make the API, and then we
   can plug this blueprint in our main application. [[http://flask.pocoo.org/docs/0.10/blueprints/][More on Flask
   blueprints]].
#+BEGIN_SRC python :tangle src/api.py :eval no :noweb yes
# -*- coding: utf-8 -*-

import os
import csv

from flask import Blueprint, request, jsonify, abort, current_app, redirect,\
    url_for

from db import *
from utils import parse_request, jsonify_list
from maps import entity_pairs
api = Blueprint('APIs', __name__)


<<bulk-update-interface>>

#+END_SRC

** REST APIs to read and query data
   These are the set of REST APIs for read operations.

*** Design
   The REST APIs to get and query data are designed in a generic
   way. That is, APIs for each entity is not designed and implemented
   specifically, rather three generic API patterns are designed which,
   presumably, will capture all kinds of query patterns.

   The three API patterns are:
   1. =/<:entity>s?query_param1=val1&query_param2=val2&..query_paramn=valn=
   2. =/<:entity>s/<:id>?fields=field1,field2,field3=
   3. =/<:entity>s/<:id>/<entity>s?query_param1=val1&query_param2=val2=

   =<:entity>s= are defined in the corresponding look up table.

   Let's explain each URL pattern:
   1. The first URL pattern is to get record(s) of an entity which
      satisfies some query parameters. Note, if one does not pass any
      query parameter, it returns all records of that entity.  For
      example:
      1. To get all labs of IIIT-H at integration level 6 and hosted on
         AWS:
        #+BEGIN_EXAMPLE
	GET /labs?integration_level=6&institute=iiith&hosted_on=AWS
	#+END_EXAMPLE
      2. To get all labs in the system:
         #+BEGIN_EXAMPLE
	 GET /labs
	 #+END_EXAMPLE
      3. To get all the developers associated with IIIT-H:
         #+BEGIN_EXAMPLE
	 GET /developers?institute=iiith
	 #+END_EXAMPLE
   2. The second URL pattern is to get details of a particular record,
      identified by a unique identifier =id=. The records can be
      further filtered down with only desired attributes.  For example:
      1. Get only few details the Data Structures lab (where the lab
         id is known before):
         #+BEGIN_EXAMPLE
	 GET /labs/cse02?fields=name,institute,hosted_url
	 #+END_EXAMPLE
      2. Get all the details of particular developer (presuming the id
         is known beforehand):
         #+BEGIN_EXAMPLE
	 GET /developers/22
	 #+END_EXAMPLE
   3. The third URL pattern is to get record(s) of an entity which is
      part of another entity. Like to get experiments / technologies /
      developers of a lab, or to get labs of an institute. The
      record(s) can also be filtered on some query parameters. Like to
      get all the technologies of a lab which are non FOSS.  For
      example:
      1. Get all technologies of a lab which are non FOSS:
         #+BEGIN_EXAMPLE
	 GET /labs/cse02/technologies?foss=false
	 #+END_EXAMPLE
      2. Get all experiments of a lab which uses Java3D and Flash:
         #+BEGIN_EXAMPLE
	 GET /labs/cse02/experiments?technologies=java3d,flash
	 #+END_EXAMPLE


   Note that, nesting of entities in the URL API is only allowed till
   2nd level. Arbitrary nesting of entities might have the problem of
   falling into infinite loop while querying.

   Also note that, attributes with multiple values are
   comma-separated; and the default action is to use AND operation
   among them. If the OR operation is needed, they need to be
   substituted by '+'. Example: To get all experiments of a lab which
   uses Java3D OR Flash:
   #+BEGIN_EXAMPLE
   GET /labs/cse02/experiments?technologies=java3d+flash
   #+END_EXAMPLE

   In the above, a valid =<:entity>s= can be any of the keywords
   defined in the look up table. Like, =labs=, =disciplines=,
   =experiements=, =developers=. Note that the entity name is always
   plural, but the look up table maps the plural keyword to a
   particular entity (which is usually in singular form).

   Look up table would be like (this is an example, not the
   implementation):
#+BEGIN_SRC python
  entity_map = {
      'labs': Lab,
      'institutes': Institute,
      'experiments': Experiment,
      'disciplines': Discipline,
      'developers': Developer,
      'technologies': Technology
  }
#+END_SRC

   **TODO**: usage documentation of all REST APIs for the consumers of
   data service has to be written down somewhere and published.

*** Implementation

#+BEGIN_SRC python :tangle src/maps.py :eval no

lab = {'entity_class': 'Lab',
       'attributes': [
           {'name': 'id',
            'class': 'None',
            'relationship': 'one'},
           {'name': 'name',
            'class': 'None',
            'relationship': 'one'},
           {'name': 'lab_id',
            'class': 'None',
            'relationship': 'one'},
           {'name': 'institute',
            'class': 'Institute',
            'relationship': 'one'},
           {'name': 'discipline',
            'class': 'Discipline',
            'relationship': 'one'},
           {'name': 'integration_level',
            'class': 'IntegrationLevel',
            'relationship': 'one'},
           {'name': 'developers',
            'class': 'Developer',
            'relationship': 'many'},
           {'name': 'experiments',
            'class': 'Experiment',
            'relationship': 'many'},
           {'name': 'technologies',
            'class': 'Technology',
            'relationship': 'many'},
           {'name': 'repo_url',
            'class': 'None',
            'relationship': 'one'},
           {'name': 'hosted_url',
            'class': 'None',
            'relationship': 'one'},
           {'name': 'hosted_on',
            'class': 'HostingPlatform',
            'relationship': 'one'},
           {'name': 'type_of_lab',
            'class': 'TypeOfLab',
            'relationship': 'one'},
           {'name': 'remarks',
            'class': 'None',
            'relationship': 'one'},
           {'name': 'status',
            'class': 'None',
            'relationship': 'one'},
           {'name': 'is_web_2_compliant_lab',
            'class': 'None',
            'relationship': 'one'},
           {'name': 'is_phase_2_lab',
            'class': 'None',
            'relationship': 'one'}
       ]}

labs = lab

institute = {'entity_class': 'Institute',
             'attributes': [
                 {'name': 'id',
                  'class': 'None',
                  'relationship': 'one'},
                 {'name': 'name',
                  'class': 'None',
                  'relationship': 'one'},
                 {'name': 'institute_id',
                  'class': 'None',
                  'relationship': 'one'},
                 {'name': 'pic',
                  'class': 'None',
                  'relationship': 'one'},
                 {'name': 'iic',
                  'class': 'None',
                  'relationship': 'one'},
                 {'name': 'labs',
                  'class': 'Lab',
                  'relationship': 'many'},
                 {'name': 'developers',
                  'class': 'Developer',
                  'relationship': 'many'}
             ]}

entity_pairs = {
    'labs': lab,
    'institutes': institute
}

#+END_SRC

#+BEGIN_SRC python :tangle src/api.py :eval no
# query an entity
# =/<:entity>s?query_param1=val1&query_param2=val2&..query_paramn=valn=
@api.route('/<entity>', methods=['GET'])
def query_an_entity(entity):
    db_module = __import__('db')
    if entity not in entity_pairs:
        abort(400, 'Entity %s is not valid.' % entity)

    curr_entity = getattr(db_module, entity_pairs[entity]['entity_class'])
    print "=========curr_entity = %s from route===========" % curr_entity
    arg_tuple_list = request.args.lists()
    if not arg_tuple_list:
        print "data: %s" % [i.to_client() for i in curr_entity.get_all()]
        return jsonify_list([i.to_client() for i in curr_entity.get_all()])
    else:
        query = curr_entity.query
        filters = []
        for arg_tuple in arg_tuple_list:
            args = arg_tuple[0].split('.')
            values = arg_tuple[1][0].split(',')
            print "=========route function============"
            print "args: %s" % args
            print "values: %s" % values
            #    return str(arg_tuple_list)
            filters.append(create_filters(entity_pairs[entity],
                                          curr_entity,
                                          args,
                                          values))
        print "===FILTERS===="
        print filters
        for filter in filters:
            print "filter = %s" % filter

            query = query.filter(filter)
            print query
        entities = query.all()
        print entities
        print "data: %s" % [ent.to_client() for ent in entities]
        return jsonify_list([ent.to_client() for ent in entities])


def create_filters(entity_map, curr_entity, args, values):
    print "===============create_filters===================="
    print "args = %s" % args
    print "entity_map = %s" % entity_map
    print "curr_entity = %s" % curr_entity
    maps_module = __import__('maps')
    db_module = __import__('db')
    if len(args) == 1:
        print getattr(curr_entity, args[0]).in_(values)
        return getattr(curr_entity, args[0]).in_(values)
    else:
        result = filter(lambda item: item['name'] == args[0],
                        entity_map['attributes'])
        print "result = %s" % result
        if not result:
            raise AttributeError("attribute %s not found" % args[0])

        entity_map = getattr(maps_module, args[0])
        if result[0]['relationship'] == 'one':
            return getattr(curr_entity, args[0]).has(
                create_filters(entity_map,
                               getattr(db_module, result[0]['class']),
                               args[-1:],
                               values))
        else:
            return getattr(curr_entity, args[0]).any(
                create_filters(entity_map,
                               getattr(db_module, result[0]['class']),
                               args[-1:],
                               values))


@api.route('/<entity>/<id>', methods=['GET'])
def get_specific_entity(entity, id):
    if entity not in entity_pairs:
        abort(400, 'Entity %s is not valid.' % entity)

    curr_entity = entity_map_types[entity]['entity']

    record = curr_entity.get_by_id(id)
    if not record:
        abort(404, "No entry for %s with id: %s found." % (entity, id))

    return jsonify(record.to_client())

@api.route('/<entity>/<id>/<entity2>', methods=['GET'])
def get_entity_of_a_specific_entity(entity, id, entity2):
    if entity not in entity_pairs:
        abort(400, 'Entity %s is not valid.' % entity)

    curr_entity = entity_map_types[entity]['entity']

    record = curr_entity.get_by_id(id)
    if not record:
        abort(404, "No entry for %s with id: %s found." % (entity, id))

    # check if the entity2 is an attr of entity
    if entity2 not in entity_map_types[entity]['types']:
        abort(400, 'Entity %s is not valid attribute of %s' % (entity2, entity))

    #FIXME: ugly hack, I know! :/. I don't know how to get the attr
    # otherwise..
    result = record.__getattribute__('get_'+entity2)()
    return jsonify_list([i.to_client() for i in result])


#+END_SRC
** REST API to create/update/delete data

*** Design
   These REST of APIs include APIs to perform create, update and
   delete operations.
   These REST APIs will implement the HTTP methods:
   1. POST - to create new entries
   2. PUT - to update existing entries
   3. DELETE - to delete existing entries

   These REST APIs are designed in a generic way. That is, APIs for
   each entity is not designed and implemented specifically, rather
   generic API patterns are designed to capture creation, updation and
   deletion on all entities.

   This is achieved using a look up table which contains valid entries
   for valid entities. The look up table is same as above, explained
   in the "REST APIs to get and query all information" section above.

   The API should look into the URL of the request, and verify if the
   request is for a valid entity from the look up table. Once it
   verifies the valid entity, then it should invoke the constructor or
   the appropriate setter function of the corresponding entity found
   in the look up table. For invoking the constructor/setter and
   passing the values to the constructor, the API needs to know the
   type of each argument in the constructor. This can also be achieved
   through the look up table. Hence, the look up table for this
   similar to above, but with more information regarding types of
   arguments of each of the constructors.

   The look up table should like the following: (this is just an
   example, not the implementation)
#+BEGIN_SRC python
entity_map_types = {
    'labs': {
        'entity': Lab,
        'types': {
            'name': str,
            'institute': Institute,
            'hosted_url': URL,
            'technologies': Technology,
        }
    },
    'disciplines': {
        'entity': Discipline,
        'types': {
            'name': str,
            'discipline_id': str,
            'dnc': Name
        }
    }
}
#+END_SRC

**** API to create new entries
   The generic API pattern for creating new entries is:
   POST =/<:entity>s/=
   That is, create a POST request using =/<:entity>s= as the URL
   endpoint.

   For example,
   #+BEGIN_EXAMPLE
   1. POST /labs
   2. POST /institutes
   #+END_EXAMPLE
   The request body of the POST request contain the relevant data for
   the request.

   The API creates a new entry, on success it returns a JSON object
   with the new record, on failure, it should throw an appropriate
   HTTP response code.

   Essentially, the API should pick up the correct entity from the
   look up table based on the request. And then based on the body of
   the request it should go through the types of entity and create
   instance of the type from the value found in the request body. If
   there is mis-match or error in creating the types, the API should
   HTTP 400 (which stands for bad or mal-formed request). Once the
   correct type of each request variable is formed, it can then pass
   the values to the corresponding constructor of the entity. If the
   constructor throws an error, again the API should return 400. If
   the construction is successful, the API tries to save it to the
   database. If there is an error, the API should return 500 and log
   the error. If the database save is successful, then the API returns
   HTTP 200 and sends the JSON representation of the new entry in the
   body of the response.

**** API to update entries
     The generic URL pattern to update existing entries is
     PUT =/<:entity>s/<:id>=

     That is, create a PUT request using =/<:entity>s/<:id>= as the URL
     endpoint.

     For example,
     #+BEGIN_EXAMPLE
     1. PUT /labs/cse22
     2. PUT /institutes/iith
     #+END_EXAMPLE
     The request body of the PUT request contain the relevant data for
     the request.

     The API updates the existing entry based on the corresponding id
     of the entity; on success it returns a JSON object
     with the new record, on failure, it should throw an appropriate
     HTTP response code.

     Essentially, the API should pick up the correct entity from the
     look up table based on the request. And then based on the =id= in
     the request it tries to fetch the existing entity. If the entry
     doesn't exist it returns a HTTP 404. If the entry exists, then
     based on the body of the request (how many attributes the request
     wants to update) it should go through the types of entity and
     create instance of the type from the value found in the request
     body. If there is mis-match or error in creating the types, the
     API should HTTP 400 (which stands for bad or mal-formed
     request). Once the correct type of each request variable is
     formed, it can then pass the values to the corresponding setter
     function(s) of the entity. If the setter function(s) throws an
     error, again the API should return 400. If the update is
     successful, the API tries to save it to the database. If there is
     an error, the API should return 500 and log the error. If the
     database save is successful, then the API returns HTTP 200 and
     sends the JSON representation of the new entry in the body of the
     response.

**** API to delete entries
     The generic URL pattern to delete existing entries is:
     DELETE =/<:entity>s/<:id>=

     That is, create a DELETE request using =/<:entity>s/<:id>= as the URL
     endpoint.

     For example,
      #+BEGIN_EXAMPLE
      1. DELETE /labs/cse22
      2. DELETE /institutes/iith
      #+END_EXAMPLE

     The API deletes the existing entry based on the corresponding id
     of the entity; on success it returns a HTTP 200 OK; on failure,
     it should throw an appropriate HTTP response code.

     Essentially, the API should pick up the correct entity from the
     look up table based on the request. And then based on the =id= in
     the request URL, it tries to fetch the existing entry. If no such
     entry exist, it returns a HTTP 404. If the entry exist, then it
     issues a delete method call to the ORM with the current
     object. If this operation is successful, it returns a 200 OK,
     else it returns a HTTP 500 and logs the error.

*** Implementation
**** The entity look up table with corresponding types of their attributes
#+NAME: entity-map-types
#+BEGIN_SRC python
entity_map_types = {
    'labs': {
        'entity': Lab,
        'types': {
            'name': str,
            'lab_id': str,
            'institute': Institute,
            'discipline': Discipline,
            'integration_level': IntegrationLevel,
            'repo_url': URL,
            'hosted_url': URL,
            'hosted_on': HostingPlatform,
            'type_of_lab': TypeOfLab,
            'remarks': str,
            'status': str,
            'is_web_2_compliant': bool,
            'is_phase_2_lab': bool,
            'technologies': Technology,
            'experiments': Experiment,
            'developers': Developer
        }
    },
    'institutes': {
        'entity': Institute,
        'types': {
            'name': str,
            'institute_id': str,
            'pic': Name,
            'iic': Name
        }
    },
    'disciplines': {
        'entity': Discipline,
        'types': {
            'name': str,
            'discipline_id': str,
            'dnc': Name
        }
    },
    'developers': {
        'entity': Developer,
        'types': {
            'name': Name,
            'email': Email,
            'institute': Institute
        }
    },
    'technologies': {
        'entity': Technology,
        'types': {
            'name': str,
            'version': str,
            'foss': bool
        }
    },
    'experiments': {
        'entity': Experiment,
        'types': {
            'name': str,
            'lab': Lab,
            'content_url': URL,
            'simulation_url': URL,
            'content_hosted_on': HostingPlatform,
            'simulation_hosted_on': HostingPlatform,
            'technologies': Technology
        }
    },
    'feedback': {
        'entity': Feedback,
        'types': {
            'lab': Lab,
            'experiment': Experiment,
            'user_name': Name,
            'user_email': Email,
            'user_institute': str,
            'user_discipline': str,
            'ip': str,
            'type_of_user': str,
            'experiment_attempted': bool,
            'experiment_works': bool,
            'if_no_what_issue': str,
            'problem_while_performing_experiment': str,
            'most_interesting_things': str,
            'why_how_plan_to_use_vlabs': str,
            'suggestions': str
        }
    }
}
#+END_SRC

**** The API to update/delete entries
***** API route definition
The API route definitions. Defining the =/entity/id= API for update and delete
operations. The following API handler first checks if the requested URL is a
valid entity. If not it sends back a HTTP 400. If it is a valid entity, then
it looks at the HTTP method, and calls the appropriate function to actually
delete or update an existing record.
#+NAME: modify-entity
#+BEGIN_SRC python
@api.route('/<entity>/<id>', methods=['PUT', 'DELETE'])
def modify_entity(entity, id):
    if entity not in entity_map_types:
        abort(400, 'Entity %s is not valid.' % entity)

    curr_entity = entity_map_types[entity]['entity']

    if request.method == 'DELETE':
       status = delete_record(curr_entity, id)
       return status

    if request.method == 'PUT':
        status = update_record(entity, curr_entity, id)
        return status
#+END_SRC

***** Delete Record function
The function to delete a record given an entity and a id. On success, it
returns the =id= and a ~status=success~ as a JSON. If no such record with the
given =id= is found, it return a HTTP 404 not found error. If the record is
found, but there was error deleting the record, it sends back a HTTP 500 with
corresponding error.
#+NAME: delete-record
#+BEGIN_SRC python
def delete_record(entity, id):
    record = entity.get_by_id(id)
    if not record:
        abort(404, 'No %s with id %s' % (entity, id))
    else:
        try:
            record.delete()
            #db.session.delete(record)
            #db.session.commit()
        except Exception, e:
            print e
            abort(500, str(e))

    return jsonify(id=id, status="success")
#+END_SRC

***** Update Record function
The function to update an record given the entity name, the actual entity,
=id= of the record and the request object which has the data to be updated.
Following steps:
1. Check if the record with given =id= exist.
   1. If record doesn't exist, send back a HTTP 404 error.
2. If record exist, parse the request data into a =dict=, if the =dict= is
   empty or malformed send back a HTTP 400 error.
3. Now the request =dict= contains the request data, but they are all in
   strings. To handover the data to actually operate on to update, the data
   has to be converted to correct types, looking at the lookup table which has
   the type information. This type conversion is handled by the function
   =typecast_data=.
4. Once, the data is type converted, it calls the =update= method on the
   record.
5. If the =update= is not successful, it will send back a HTTP 500 with
   corresponding error.
6. If success, it will send back a JSON with the updated record.
#+NAME: update-record
#+BEGIN_SRC python
def update_record(entity_name, entity, id):
    record = entity.get_by_id(id)

    if not record:
        abort(404, 'No %s with id %s' % (entity_name, id))

    data = parse_request(request)
    if not data or type(data) is not dict:
        abort(400, "The data should be in JSON format")

    data = typecast_data(entity_name, data)
    print "updated, typecasted data: %s" % data

    try:
        print "Updating record: %s with data: %s" % (record, data)
        record.update(**data)
    except Exception, e:
        print e
        abort(500, str(e))

    return jsonify(record.to_client())
#+END_SRC

***** Typecast Data function
The method to typecast the data. It takes in an entity, and the data in a
=dict= format; and returns another =dict= with all the values having correct
types, based on the passed entity (this information is stored in the lookup
table with entity, its attributes and their type information). The following
functions just takes each item in the data =dict=, finds out its corresponding
constructor from the type information and calls the =typecast_item= function
over it.
#+NAME: typecast-data
#+BEGIN_SRC python
def typecast_data(entity, data):
    updated_data = {}
    for attr, val in data.iteritems():
        print "attr: %s, val: %s" % (attr, val)
        if attr not in entity_map_types[entity]['types']:
            abort(400, '%s attribute not in %s' % (attr, entity))
        const = entity_map_types[entity]['types'][attr]
        print "const for %s is %s" % (attr, const)

        if type(val) is list:
            new_val = map(lambda item: typecast_item(const, attr, item), val)
        else:
            new_val = typecast_item(const, attr, val)

        updated_data[attr] = new_val

    return updated_data
#+END_SRC

The function takes in a constructor, the attribute name and the actual
attribute value, and returns the new value typecasted to its correct type.
If the attribute is a compound item (like that itself is a =dict=), then it
calls the =typecast_compound_item= function. Else if it is a simple attribute
it just calls the constructor over the value. If the constructor throws an
error, the function returns a HTTP 400 error.
#+NAME: typecast-item
#+BEGIN_SRC python
# take a constructor, and attr name and the actual attribute and convert the
# attribute value to its actual type
def typecast_item(const, attr, val):
    if type(val) is dict:
        new_val = typecast_compound_item(const, attr, val)
        return new_val

    try:
        new_val = const(val)
    except TypeError:
        abort(400, '%s is not a valid %s' % (val, attr))

    print "new val after const: %s" % new_val
    return new_val
#+END_SRC

The function takes in a constructor, the attribute name and the actual
attribute value, and returns the new value typecasted to its correct type.
Here the assumption is, that the value that it has been passed is of type
=dict=, and the =dict= contains an =id= field, which means this value is an
existing record. Hence, this function calls the =get_by_id= method of the
constructor (or the type). If there is an error it sends back appropriate HTTP
error codes.
#+NAME: typecast-compound-item
#+BEGIN_SRC python
# take a constructor, and attr name and the actual attribute and convert the
# attribute value to its actual type
def typecast_compound_item(const, attr, val):
    if 'id' not in val:
        abort(400, "id attr has to be present in %s:%s" % (attr,
                                                           val))
    try:
        new_val = const.get_by_id(val['id'])
    except TypeError:
        abort(400, '%s is not a valid %s' % (val, attr))

    if not new_val:
        abort(404, 'id %s of %s is not found' % (val['id'], attr))
    print "new val after const: %s" % new_val
    return new_val

#+END_SRC

***** Code tangle
In the below, all the above code blocks are arranged in the order the python
interpreter expects them to be.
#+BEGIN_SRC python :tangle src/api.py :eval no :noweb yes
<<entity-map-types>>

<<delete-record>>

<<typecast-compound-item>>

<<typecast-item>>

<<typecast-data>>

<<update-record>>

<<modify-entity>>
#+END_SRC


**** The API to create new entries
***** API route definition
#+NAME: create-entity
#+BEGIN_SRC python
@api.route('/<entity>', methods=['POST'])
def create_entity(entity):
    if entity not in entity_map_types:
        abort(400, 'Entity %s is not valid.' % entity)

    curr_entity = entity_map_types[entity]['entity']

    status = create_record(entity, curr_entity)
    return status

#+END_SRC
***** Create Record function
#+NAME: create-record
#+BEGIN_SRC python
def create_record(entity_name, entity):

    data = parse_request(request)
    if not data or type(data) is not dict:
        abort(400, "The data should be in JSON format")

    data = typecast_data(entity_name, data)
    print "creating new, typecasted data: %s" % data

    try:
        print "Creating record: %s with data: %s" % (entity_name, data)
        new_record = entity(**data)
        new_record.save()
    except Exception, e:
        print e
        abort(500, str(e))

    return jsonify(new_record.to_client())
#+END_SRC


***** Code tangle
#+BEGIN_SRC python :tangle src/api.py :eval no :noweb yes
<<create-record>>
<<create-entity>>
#+END_SRC

** Published document for the REST APIs
All APIs of data service are REST-ful. They use HTTP verbs for
denoting action on various resources.

|-------------+-------------------------|
| HTTP Method | Action                  |
|-------------+-------------------------|
| GET         | Get or Read resource(s) |
| POST        | Create a resource       |
| PUT         | Update a resource       |
| DELETE      | Delete a resource       |
|-------------+-------------------------|

All APIs follow the pattern of =/<some-resource>/<identifier>=
Example:
+ =/labs=
+ =/developers/12=

All responses from data service are in JSON format.
If the request is success, it will return the result in a JSON format.
If the request is failure, it will return a JSON with the key as
=error= and the value of that key as the error description.

*** Feedback Data
1. Submit feedback data
Submit feedback data to the data service.
=POST /feedback=
*Parameters*:
|-------------------------------------+---------+------------------------------------------------------------------------------------------------------------|
| Name                                | Type    | Description                                                                                                |
|-------------------------------------+---------+------------------------------------------------------------------------------------------------------------|
| lab                                 | object  | Lab as a JSON object containing the =id= of the lab                                                        |
| experiment                          | object  | Experiment as a JSON object containing the =id= of the experiment                                          |
| user_name                           | string  | Name of the user submitting feedback                                                                       |
| user_email                          | string  | Email address of the user                                                                                  |
| user_institute                      | string  | Institute name of the user                                                                                 |
| user_discipline                     | string  | Discipline of the user                                                                                     |
| ip                                  | string  | IP address of user from where the request came                                                             |
| type_of_user                        | string  | Type of the user like student, faculty etc.                                                                |
| experiment_attempted                | boolean | =true= if experiment attempted else =false=                                                                |
| experiment_works                    | boolean | =true= if experiment worked else =false=                                                                   |
| if_no_what_issue                    | string  | field for answer to question: "If no, what is the issue with it?"                                          |
| problem_while_performing_experiment | string  | field for answer to question: "Specify the problems or difficulties faced while performing the experiment" |
| most_interesting_things             | string  | field for answer to question: "What are the most interesting things about the experiment"                  |
| why_how_plan_to_use_vlabs           | string  | field for answer to question: "Why and how often do you plan to use Virtual Labs"                          |
| suggestions                         | string  | field for answer to question: "What are your suggestions about making them better"                         |
|-------------------------------------+---------+------------------------------------------------------------------------------------------------------------|
Where the =lab= parameter is mandatory, all other parameters are
optional.
Example:
#+BEGIN_EXAMPLE
{
  "experiment": {"id": 1},
  "experiment_attempted": true,
  "experiment_works": false,
  "if_no_what_issue": "keuh! kiagkwdba ks, asad.",
  "ip": "14.15.16.7",
  "lab": {
    "id": 1,
    "lab_id": "CSE02",
    "name": "Data Structures"
  },
  "most_interesting_things": "riasjfufhbckfuygfksfkebf eugfskfem",
  "problem_while_performing_experiment": "3uikjklshfeyr#R&YFB fIUGfIBFF",
  "suggestions": "rbkrjsfgkkbvkr",
  "type_of_user": "student",
  "user_discipline": "electronics",
  "user_email": "joe@smith.com",
  "user_institute": "GNIT, Hyderabad",
  "user_name": "Joe Smith",
  "why_how_plan_to_use_vlabs": "No Plans"
}
#+END_EXAMPLE

2. Get all feedback data
To list all feedback data, make a =GET= request to =/feedback=
=GET /feedback=

3. Get specific feedback data
Get a specific feedback data using the identifier =id=.
Make a =GET= request to =/feedback= with the =id=

=GET /feedback/<id>=

** Custom Exceptions

These are spme of the custom exceptions used in the application.
*** AttributeRequired
#+BEGIN_SRC python :tangle src/ds_exceptions.py :eval no
class AttributeRequired(Exception):
    str = None

    def __init__(self, str):
        self.str = str

    def __str__(self):
        return repr(self.str)

#+END_SRC
** Utility Functions
#+BEGIN_SRC python :tangle src/utils.py :eval no
# module to hold all utilities/helper functions

import json

from flask import make_response, current_app


# return a list of dicts as json with correct mime types
# flask does not provide a jsonify for lists; hence this method
def jsonify_list(data):
    if type(data) is not list:
        raise Exception('jsonify_list function accepts only a list')

    return make_response(json.dumps(data), 200,
                         {'content-type': 'application/json'})


# take in a flask request object and try to parse out a dictionary from the
# request
# try to find if request is as JSON first, then look into forms, finally force
# find it.
# If not found return a dict; else return the parsed data
def parse_request(request):
    if request.json:
        # print 'found in request.json'
        data = request.get_json()

    elif request.data:
        # print 'found in request.data'
        data = json.loads(request.data)

    elif request.form:
        # print 'found in request.form'
        data = request.form.to_dict()
        # try to detect if form contains integers and boolean data and attempt
        # to convert them
        # FIXME: is this a good idea? Fix this to do it in a better way?
        for k in data:
            if is_number(data[k]):
                data[k] = int(data[k])
            if is_bool_in_str(data[k]):
                data[k] = str_to_bool(data[k])

            # print k, data[k]

    else:
        data = request.get_json(force=True)

    if not data:
        return False

    return data


# check if a given string is a number
def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False


# check if in a given string python bool types are represented
def is_bool_in_str(s):
    if s == "True" or s == "False":
        return True
    return False


# convert python bool types in string to native bool types
def str_to_bool(s):
    if s == "True":
        return True
    if s == "False":
        return False
    return None


# decorator to do typechecking of arguments passed to functions
# usage: @typecheck(var1=<type>, var2=(<type1>, <type2>), ..)
#        def yourfunc(var1, var2, ..):
#           ....
def typecheck(**typemap):
    """
    Decorator to do typechecking of arguments passed to functions. Similar to
    function annotations in Python 3, but this also does strict type checking
    when a function is called.
    The type to an argument can be single or multiple types. Mutiple types are
    to be specified in a tuple.
    Usage:
        @typecheck(var1=<type>, var2=(<type1>, <type2>), ..)
        def yourfunc(var1, var2, ..):
            ....
    """
    # print "all valid types: %s" % typemap

    def make_wrapper(decorated_func):

        def wrapper(*arg_vals, **kw_vals):
            # TODO: have more comments to better describe each line
            arg_names = decorated_func.func_code.co_varnames
            # print arg_names
            # if not arg_vals:
            #     print kw_vals
            #     # arg_vals = kw_vals
            # print arg_vals

            # iterate over the typemap passed to the typecheck decorator and
            # compare with the actual arguments passed to the function
            for key, val in typemap.iteritems():
                arg_name = key
                idx = arg_names.index(arg_name)
                arg = arg_vals[idx]
                # print "arg_name: %s, arg: %s, typemap[arg_name]: %s" %\
                #    (arg_name, arg, typemap[arg_name])

                # if the passed type is a list throw an error
                if typemap[arg_name] is list:
                    raise SyntaxError("The types of %s has to be a tuple, "
                                      "not list. \n See usage of `typecheck`" %
                                      arg_name)

                # check if the passed type is a tuple, if not make it
                if typemap[arg_name] is not tuple:
                    types = (typemap[arg_name],)
                else:
                    types = typemap[arg_name]

                # iterate over the `types` tuple to see the arg matches any of
                # the type provided in the tuple
                if True not in map(lambda type: isinstance(arg, type), types):
                    # print "types are not fine"
                    raise TypeError("For %s type should have been %s. But "
                                    "provided: %s" % (arg_name,
                                                      typemap[arg_name],
                                                      type(arg)))

            return decorated_func(*arg_vals, **kw_vals)
        return wrapper

    return make_wrapper

#+END_SRC

** Authentication

   Authentication is a problem that has to be tackled by data
   service.

   Authentication, in this context, means how data service will
   authenticate (or verify the identity of) various other services
   communicating with it.

   For example, data service might allow only ADS or Dashboard to
   update and create data but not other services. How will data
   service guarantee that it only allows the correct ADS service or
   the Dashboard service to modify the data and not some other
   service.

*** Design
    Design decision is, data service will allow GET requests from any
    client. It does not restrict getting information from it.

    But for services or clients which want to create, update or delete
    any data, the data service has to be pre-configured to authorize
    these identified services. Then, the data service can authenticate
    these services/clients which want to modify any data. The
    techniques for authentication are as follows:

   + By Restricting IP addresses:

     Here the assumption is that data service is aware of
     other services such as ADS or Dashboard, which will communicate
     with it.

     According to this technique, data service will identify those IP
     addresses from which HTTP requests will be accepted. Essentially,
     it knows the IP addresses of other services where they are
     running.

     Each time a web request is received, data service will compare
     the IP address with the list of acceptable IPs. If IP is on the
     list, the request is served normally, else it returns a
     "Forbidden: IP address rejected" error.

   + By CORS (Cross Origin Resource Sharing) policy for AJAX requests:

     Since data service is aware of the services communicating with it
     (assumption it also knows the FQDN of those services), it will
     accept AJAX requests coming *only* from these services.


    *TODO* Define a process in =dataservice= for configuring
     authentication in case a new microservice is introduced.

*** Technical Design
    Technically, this will be achieved via a decorator. The decorator will
    check if the incoming request is from a white-listed IP address.

    Then the required URL endpoints can use the decorator to guard access
    to that endpoint.

*** Implementation
    The function is part of the =utils= module.

#+BEGIN_SRC python :tangle src/utils.py :eval no

def check_ip(fn):
    def wrapped_func(*args, **kwargs):
        if request.remote_addr not in current_app.config.WHITELIST_IPS:
            abort(403)
        return fn(*args, **kwargs)
    return wrapped_func
#+END_SRC
*** Usage of this function
To use this function, use it as a decorator to check for access to any route.
#+BEGIN_EXAMPLE python
  @app.route('/labs', methods=['POST'])
  @check_ip
  def create_lab():
      #some code here..
#+END_EXAMPLE

*Note* that you cannot use the decorator before the =route=
 decorator. You have to use it after it.
The following code will *not* work:
#+BEGIN_EXAMPLE
  @check_ip
  @app.route('/labs', methods=['POST'])
  def create_lab():
      #some code here.
#+END_EXAMPLE

** The web application
#+BEGIN_SRC python :tangle src/app.py :eval no
# -*- coding: utf-8 -*-

import os
import logging
from logging.handlers import RotatingFileHandler

from flask import Flask, jsonify, make_response
from flask.ext.cors import CORS

from db import db
from api import api
# import config file
import config


def create_app(config):
    # init our app
    app = Flask(__name__)

    # load config values from the config file
    app.config.from_object(config)

    # init sqlalchemy db instance
    db.init_app(app)
    db.app = app

    # register blueprints
    app.register_blueprint(api)

    configure_errorhandlers(app)
    configure_cors(app)
    configure_logging(app)

    # all set; return app object
    return app


# configure cross origin resource sharing
def configure_cors(app):
    # CORS(app)
    CORS(app, origins=config.ALLOWED_ORIGINS,
         methods=['GET', 'OPTIONS', 'PUT', 'POST'],
         allow_headers='Content-Type')


# custom error handlers to return JSON errors with appropiate status codes
def configure_errorhandlers(app):

    @app.errorhandler(400)
    def bad_request(err):
        return make_response(jsonify(error=err.description), 400)

    @app.errorhandler(404)
    def not_found(err):
        return make_response(jsonify(error=err.description), 404)

    @app.errorhandler(405)
    def method_not_allowed(err):
        return make_response(jsonify(error=err.description), 405)

    @app.errorhandler(500)
    def server_error(err):
        try:
            return make_response(jsonify(error=err.description), 500)
        except Exception:
            try:
                return make_response(jsonify(error=err.message), 500)
            except Exception:
                return make_response(jsonify(error=str(err)), 500)


def configure_logging(app):
    formatter = logging.Formatter('%(asctime)s: %(levelname)s: %(filename)s:'
                                  ' %(funcName)s():%(lineno)d: %(message)s')

    if 'LOG_FILE' in app.config:
        log_filename = app.config['LOG_FILE']
    else:
        log_filename = 'dataservice.log'
    # Also error can be sent out via email. So we can also have a SMTPHandler?
    log_file = os.path.join(os.path.dirname(__file__), '..', log_filename)

    max_size = 1024 * 1024 * 20  # Max Size for a log file: 20MB
    log_handler = RotatingFileHandler(log_file, maxBytes=max_size,
                                      backupCount=10)

    if 'LOG_LEVEL' in app.config:
        log_level = app.config['LOG_LEVEL'] or 'ERROR'
    else:
        log_level = 'ERROR'

    log_handler.setLevel(log_level)
    log_handler.setFormatter(formatter)

    app.logger.addHandler(log_handler)


if __name__ == "__main__":
    app = create_app(config)
    app.run(debug=True, host='0.0.0.0')

#+END_SRC

** Configuring the application
Below is the configuration for the application
#+BEGIN_SRC python :tangle src/config.py :eval no
# DB URI
# example DB URI:
# mysql+oursql://scott:tiger@localhost/mydatabase
# postgresql+psycopg2://scott:tiger@localhost/mydatabase
SQLALCHEMY_DATABASE_URI = 'mysql+oursql://<userid>:<password>@<servername>/<db_name>'
# example
#SQLALCHEMY_DATABASE_URI = 'mysql+oursql://root:mysql@localhost/dataservice'

# Debug from SQLAlchemy
# Turn this to False on production
SQLALCHEMY_ECHO = False

# List of allowed origins for CORS
ALLOWED_ORIGINS = ["*.vlabs.ac.in", "*.virtual-labs.ac.in"]

# List of allowed IPs
WHITELIST_IPS = ["127.0.0.1"]

# Configure your log paths
LOG_FILE = 'logs/dataservice.log'

# Log level for the application
LOG_LEVEL = 'DEBUG'

# destination for uploaded files
UPLOAD_FOLDER = 'src/static/temp'

# allowed file extensions that can be uploaded
ALLOWED_EXTENSIONS = set(['csv'])

#+END_SRC

* Test Cases
** __init__
#+BEGIN_SRC python :tangle tests/__init__.py :eval no
#something
print "test package"
#+END_SRC

** Testing Python API
*** Imports and Initialization of testcases

#+BEGIN_SRC python :tangle tests/test_db.py :eval no
# -*- coding: utf-8 -*-

import unittest
from flask.ext.testing import TestCase
# import json

from src.db import *
from tests.helper import *
from src.app import create_app
from src.ds_exceptions import AttributeRequired

config = {
    'SQLALCHEMY_DATABASE_URI': ''
}
#+END_SRC

*** Tests for Custom Types
#+BEGIN_SRC python :tangle tests/test_db.py :eval no

class TestCustomTypes(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    # Test the Name type
    def test_name_type(self):
        print "test_name_type"
        new_name = Name("John")
        # correct name
        self.assertEqual(new_name.value, "John")
        # incorrect name
        self.assertRaises(TypeError, Name, "123dasd")

    # Test the Email type
    def test_email_type(self):
        print "test_email_type"
        new_email = Email("smith@gmail.com")
        # correct name
        self.assertEqual(new_email.value, "smith@gmail.com")
        # incorrect name
        self.assertRaises(TypeError, Email, "@@@@smithgmail.com")

    # Test the URL type
    def test_url_type(self):
        print "test_url_type"
        new_url = URL("http://www.gnu.org/philosophy/")
        # correct URL
        self.assertEqual(new_url.value, "http://www.gnu.org/philosophy/")
        # incorrect URL
        self.assertRaises(TypeError, URL, "@@@@smithgmail.com")

#+END_SRC

*** Tests for Lab

#+BEGIN_SRC python :tangle tests/test_db.py :eval no


class TestLab(TestCase):

    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_lab_constructor(self):
        print "test_lab_constructor"
        lab = Lab(name="DS", lab_id="cse-ds")
        self.assertEqual(isinstance(lab, Lab), True)
        self.assertEqual(lab.get_name(), "DS")
        # Calling the Lab constructor w/o any arguments should raise
        # AttributeRequired exception
        self.assertRaises(AttributeRequired, Lab)
        # Calling the Lab constructor w/o name, lab_id arguments should
        # raise AttributeRequired exception
        self.assertRaises(AttributeRequired, Lab,
                          ,**{'remarks': 'Completed'})
        # Calling the Lab constructor with required arguments (name, lab_id)
        # but Type of other arguments are wrong, should raise TypeError
        self.assertRaises(TypeError, Lab,
                          ,**{'name': Name('DS'),
                             'lab_id': 'ds',
                             'integration_level': 6
                             })

    def test_lab_get_id(self):
        print "test_lab_get_id"
        lab = Lab(name="DS", lab_id="ds")
        lab.save()
        self.assertEqual(lab.get_id(), 1)

    def test_lab_get_by_id(self):
        print "test_lab_get_by_id"
        lab = Lab(name="DS", lab_id="ds")
        lab.save()
        some_lab = Lab.get_by_id(1)
        self.assertEqual(some_lab, lab)

    def test_get_lab_id(self):
        print "test_get_lab_id"
        lab = Lab(name="DS", lab_id="ds")
        self.assertEqual(lab.get_lab_id(), "ds")

    def test_get_by_lab_id(self):
        print "test_get_by_lab_id"
        lab = Lab(name="DS", lab_id="ds")
        lab.save()
        some_lab = Lab.get_by_lab_id("ds")
        self.assertEqual(some_lab, lab)

    def test_lab_get_name(self):
        print "test_lab_get_name"
        lab = Lab(name="DS", lab_id="ds")
        self.assertEqual(lab.get_name(), "DS")

    def test_lab_get_integration_level(self):
        print "test_lab_get_integration_level"
        ilevel = IntegrationLevel(level=1)
        lab = Lab(name="DS", lab_id="ds", integration_level=ilevel)
        self.assertEqual(lab.get_integration_level(), 1)

    def test_lab_get_hosted_url(self):
        print "test_lab_get_hosted_url"
        lab = Lab(name="DS", lab_id="ds", hosted_url=URL("http://gnu.org"))
        self.assertEqual(lab.get_hosted_url(), "http://gnu.org")

    def test_lab_is_hosted(self):
        print "test_lab_is_hosted"
        #TODO: implement this!

    def test_lab_get_repo_url(self):
        print "test_lab_get_repo_url"
        lab = Lab(name="DS", lab_id="ds", repo_url=URL("http://gnu.org"))
        self.assertEqual(lab.get_repo_url(), "http://gnu.org")

    def test_lab_is_source_available(self):
        print "test_lab_is_source_available"
        #TODO: implement this!

    def test_lab_get_type_of_lab(self):
        print "test_lab_get_type_of_lab"
        lab_type = TypeOfLab(type="Simulation")
        lab = Lab(name="DS", lab_id="ds", type_of_lab=lab_type)
        self.assertEqual(lab.get_type(), lab_type)

    def test_lab_get_num_of_exps(self):
        print "test_lab_get_num_of_exps"
        lab = Lab(name="DS", lab_id="ds")
        exp1 = Experiment(name='Pendulum', lab=lab)
        exp2 = Experiment(name='Gravity', lab=lab)
        exps = [exp1, exp2]
        lab.add_experiment(exp1)
        lab.add_experiment(exp2)
        self.assertEqual(lab.get_num_of_experiments(), 2)

    def test_lab_get_hosted_on(self):
        print "test_lab_get_hosted_on"
        platform = HostingPlatform(name="Badal")
        lab = Lab(name="DS", lab_id="ds", hosted_on=platform)
        self.assertEqual(lab.get_hosted_on(), platform)

    def test_lab_is_web2_compliant(self):
        print "test_lab_is_web2_compliant"
        lab = Lab(name="DS", lab_id="ds", is_web_2_compliant_lab=True)
        self.assertEqual(lab.is_web_2_compliant(), True)

    def test_lab_is_phase_2(self):
        print "test_lab_is_phase_2"
        lab = Lab(name="DS", lab_id="ds", is_phase_2_lab=True)
        self.assertEqual(lab.is_phase_2(), True)

    def test_lab_get_remarks(self):
        print "test_lab_get_remarks"
        remarks = 'Testing phase'
        lab = Lab(name="DS", lab_id="ds", remarks=remarks)
        self.assertEqual(lab.get_remarks(), remarks)

    def test_lab_get_status(self):
        print "test_lab_get_status"
        status = 'Being Deployed'
        lab = Lab(name="DS", lab_id="ds", status=status)
        self.assertEqual(lab.get_status(), status)

    def test_lab_get_discipline(self):
        print "test_lab_get_discipline"
        disc = Discipline(name="CSE", discipline_id="cse")
        lab = Lab(name="DS", lab_id="ds", discipline=disc)
        self.assertEqual(lab.get_discipline(), disc)

    def test_lab_get_experiments(self):
        print "test_lab_get_experiments"
        lab = Lab(name="DS", lab_id="ds")
        exp1 = Experiment(name='Pendulum', lab=lab)
        exp2 = Experiment(name='Gravity', lab=lab)
        exps = [exp1, exp2]
        lab.add_experiment(exp1)
        lab.add_experiment(exp2)
        self.assertItemsEqual(lab.get_experiments(), exps)

    def test_lab_get_institute(self):
        print "test_lab_get_institute"
        instt = Institute(name="MIT", institute_id="mit")
        lab = Lab(name="DS", lab_id="ds", institute=instt)
        self.assertEqual(lab.get_institute(), instt)

    def test_lab_get_developers(self):
        print "test_lab_get_developers"
        instt = Institute(name="MIT", institute_id="mit")
        dev1 = Developer(name=Name("Joe"), email=Email("joe@mit.com"),
                         institute=instt)
        dev2 = Developer(name=Name("Poe"), email=Email("poe@mit.com"),
                         institute=instt)
        devs = [dev1, dev2]
        lab = Lab(name="DS", lab_id="ds", developers=devs)
        self.assertItemsEqual(lab.get_developers(), devs)

    def test_lab_get_technologies(self):
        print "test_lab_get_technologies"
        tech1 = Technology(name="php5")
        tech2 = Technology(name="apache2")
        techs = [tech1, tech2]
        lab = Lab(name="DS", lab_id="ds", technologies=techs)
        self.assertItemsEqual(lab.get_technologies(), techs)

    def test_lab_set_name(self):
        print "test_lab_set_name"
        lab = Lab(name="DS", lab_id="ds")
        lab.set_name("Data Structures")
        self.assertEqual(lab.get_name(), "Data Structures")
        self.assertRaises(TypeError, lab.set_name, 123)

    def test_lab_set_institute(self):
        print "test_lab_set_institute"
        lab = Lab(name="DS", lab_id="ds")
        instt = Institute(name="MIT", institute_id="mit")
        lab.set_institute(instt)
        self.assertEqual(lab.get_institute(), instt)
        self.assertRaises(TypeError, lab.set_institute, "IIT")

    def test_lab_set_discipline(self):
        print "test_lab_set_discipline"
        lab = Lab(name="DS", lab_id="ds")
        disc = Discipline(name="CSE", discipline_id="cse")
        lab.set_discipline(disc)
        self.assertEqual(lab.get_discipline(), disc)
        self.assertRaises(TypeError, lab.set_discipline, "ECE")

    def test_lab_set_integration_level(self):
        print "test_lab_set_integration_level"
        lab = Lab(name="DS", lab_id="ds")
        ilevel = IntegrationLevel(level=5)
        lab.set_integration_level(ilevel)
        self.assertEqual(lab.get_integration_level(), 5)
        self.assertRaises(TypeError, lab.set_integration_level, 6)

    def test_lab_set_hosted_url(self):
        print "test_lab_set_hosted_url"
        lab = Lab(name="DS", lab_id="ds")
        url = URL("http://ds.vlabs.ac.in")
        lab.set_hosted_url(url)
        self.assertEqual(lab.get_hosted_url(), "http://ds.vlabs.ac.in")
        self.assertRaises(TypeError, lab.set_hosted_url, "http://vlab.ac.in")

    def test_lab_set_repo_url(self):
        print "test_lab_set_repo_url"
        lab = Lab(name="DS", lab_id="ds")
        url = URL("http://ds.vlabs.ac.in")
        lab.set_repo_url(url)
        self.assertEqual(lab.get_repo_url(), "http://ds.vlabs.ac.in")
        self.assertRaises(TypeError, lab.set_repo_url, "http://vlab.ac.in")

    def test_lab_set_type_of_lab(self):
        print "test_lab_set_type_of_lab"
        lab = Lab(name="DS", lab_id="ds")
        lab_type = TypeOfLab(type="Simulation")
        lab.set_type_of_lab(lab_type)
        self.assertEqual(lab.get_type(), lab_type)
        self.assertRaises(TypeError, lab.set_type_of_lab, "Simulation")

    def test_lab_set_hosted_on(self):
        print "test_lab_set_hosted_on"
        lab = Lab(name="DS", lab_id="ds")
        plat = HostingPlatform(name="IIIT")
        lab.set_hosted_on(plat)
        self.assertEqual(lab.get_hosted_on(), plat)
        self.assertRaises(TypeError, lab.set_hosted_on, "AWS")

    def test_lab_set_web_2_compliant(self):
        print "test_lab_set_web_2_compliant"
        lab = Lab(name="DS", lab_id="ds")
        lab.set_is_web_2_compliant_lab(True)
        self.assertEqual(lab.is_web_2_compliant(), True)
        self.assertRaises(TypeError, lab.set_is_web_2_compliant_lab, "Yes")

    def test_lab_set_is_phase_2(self):
        print "test_lab_set_is_phase_2"
        lab = Lab(name="DS", lab_id="ds")
        lab.set_is_phase_2_lab(True)
        self.assertEqual(lab.is_phase_2(), True)
        self.assertRaises(TypeError, lab.set_is_phase_2_lab, "Yes")

    def test_lab_add_developer(self):
        print "test_lab_add_developer"
        lab = Lab(name="DS", lab_id="ds")
        instt = Institute(name="MIT", institute_id="mit")
        dev = Developer(name=Name("Joe"), email=Email("joe@mit.com"),
                        institute=instt)
        self.assertEqual(len(lab.get_developers()), 0)
        lab.add_developer(dev)
        self.assertEqual(len(lab.get_developers()), 1)

    def test_lab_remove_developer(self):
        print "test_lab_remove_developer"
        instt = Institute(name="MIT", institute_id="mit")
        dev = Developer(name=Name("Joe"), email=Email("joe@mit.com"),
                        institute=instt)
        lab = Lab(name="DS", lab_id="ds", developers=[dev])
        self.assertEqual(len(lab.get_developers()), 1)
        lab.remove_developer(dev)
        self.assertEqual(len(lab.get_developers()), 0)

    def test_lab_add_technology(self):
        print "test_lab_add_technology"
        lab = Lab(name="DS", lab_id="ds")
        tech = Technology(name="php5")
        self.assertEqual(len(lab.get_technologies()), 0)
        lab.add_technology(tech)
        self.assertEqual(len(lab.get_technologies()), 1)

    def test_lab_remove_technology(self):
        print "test_lab_remove_technology"
        tech = Technology(name="php5")
        lab = Lab(name="DS", lab_id="ds", technologies=[tech])
        self.assertEqual(len(lab.get_technologies()), 1)
        lab.remove_technology(tech)
        self.assertEqual(len(lab.get_technologies()), 0)

    def test_lab_add_experiment(self):
        print "test_lab_add_experiment"
        lab = Lab(name="DS", lab_id="ds")
        exp1 = Experiment(name="Pendulum", lab=lab)
        self.assertEqual(len(lab.get_experiments()), 1)
        exp2 = Experiment(name="Oscillation", lab=lab)
        lab.add_experiment(exp2)
        self.assertEqual(len(lab.get_experiments()), 2)

    def test_lab_remove_experiment(self):
        print "test_lab_remove_experiment"
        lab = Lab(name="DS", lab_id="ds")
        exp = Experiment(name="Pendulum", lab=lab)
        lab.add_experiment(exp)
        self.assertEqual(len(lab.get_experiments()), 1)
        lab.remove_experiment(exp)
        self.assertEqual(len(lab.get_experiments()), 0)

#+END_SRC

*** Tests for Institute
#+BEGIN_SRC python :tangle tests/test_db.py :eval no
class TestInstitute(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_institute_constructor(self):
        print "test_institute_constructor"
        name = "MIT"
        institute_id = "mit"
        pic = Name("John")
        iic = Name("jane")

        inst = Institute(name=name, institute_id=institute_id, pic=pic, iic=iic)
        self.assertEqual(isinstance(inst, Institute), True)

        # Calling the institute constructor without any arguments should
        # raise AttributeRequired exception
        self.assertRaises(AttributeRequired, Institute)

        # Calling the institute constructor without necessary arguments
        # like name or institute_id should raise AttributeRequired exception
        self.assertRaises(AttributeRequired, Institute,
                          **{'name': 'IIT',
                             'pic': 'Alan',
                             'iic': 'John'
                            })

        # Calling the institute constructor with necessary arguments
        # (name, institute_id) but with wrong type of other arguments should
        # raise TypeError
        self.assertRaises(TypeError, Institute,
                          **{'name': 'IIT',
                             'institute_id': 'iit',
                             'pic': Name('Alan'),
                             'iic': 'John'
                            })

    def test_set_institute_pic(self):
        print "test_set_institute_pic"
        instt = Institute(name="IndianInstitute", institute_id="ii",
                          pic=Name("Avinash"), iic=Name("Amit"))
        new_pic = Name("John Doe")
        instt.set_pic(new_pic)
        self.assertEqual(instt.pic, "John Doe")

    def test_set_institute_iic(self):
        print "test_set_institute_iic"
        instt = Institute(name="IndianInstitute", institute_id="ii",
                          pic=Name("John"), iic=Name("Amit"))
        new_iic = Name("Jane Doe")
        # print new_iic
        instt.set_iic(new_iic)
        self.assertEqual(instt.iic, "Jane Doe")

    def test_set_institute_name(self):
        print "test_set_institute_name"
        instt = Institute(name="IndianInstitute", institute_id="ii",
                          pic=Name("John"), iic=Name("Amit"))
        new_name = "BHU"
        instt.set_name(new_name)
        self.assertEqual(instt.name, "BHU")

    def test_get_institute_name(self):
        print "test_get_institute_name"
        instt = Institute(name="IndianInstitute", institute_id="ii",
                          pic=Name("John"), iic=Name("Jane"))
        inst_name = instt.get_name()
        self.assertEqual(inst_name, "IndianInstitute")

    def test_get_institute_id(self):
        print "test_get_institute_id"
        instt = Institute(name="MIT", institute_id="mit")
        self.assertEqual(instt.get_institute_id(), "mit")

    def test_get_institute_pic(self):
        print "test_get_institute_pic"
        instt = Institute(name="IndianInstitute", institute_id="ii",
                          pic=Name("John"), iic=Name("Jane"))
        inst_pic = instt.get_pic()
        self.assertEqual(inst_pic, "John")

    def test_get_institute_iic(self):
        print "test_get_institute_iic"
        instt = Institute(name="IndianInstitute", institute_id="ii",
                          pic=Name("John"), iic=Name("Jane"))
        inst_iic = instt.get_iic()
        self.assertEqual(inst_iic, "Jane")

    def test_get_id_of_institute(self):
        print "test_get_id_of_institute"
        instt = Institute(name="SomeInstitute", institute_id="si")
        instt.save()
        institute_id = instt.get_id()
        self.assertEqual(institute_id, 1)

    def test_get_institute_by_id(self):
        print "test_get_institute_by_id"
        instt = Institute(name="IndianInstitute", institute_id="ii",
                          pic=Name("John"), iic=Name("Jane"))
        instt.save()
        self.assertEqual(instt.get_by_id(1).name, "IndianInstitute")

    def test_get_by_institute_id(self):
        print "test_get_by_institute_id"
        instt = Institute(name="MIT", institute_id="mit")
        instt.save()
        some_instt = Institute.get_by_institute_id("mit")
        self.assertEqual(some_instt, instt)

    def test_get_institute_labs(self):
        print "test_get_institute_labs"
        instt = Institute(name="MIT", institute_id="mit")
        lab1 = Lab(name="Micro Controllers", lab_id="micro", institute=instt)
        lab2 = Lab(name="Digital Logic Design", lab_id="digital", institute=instt)
        labs = [lab1, lab2]
        self.assertItemsEqual(instt.get_labs(), labs)

    def test_get_institute_developers(self):
        print "test_get_institute_developers"
        instt = Institute(name="MIT", institute_id="mit")
        dev1 = Developer(name=Name("Alan"), email=Email("alan@example.com"), institute=instt)
        dev2 = Developer(name=Name("john"), email=Email("john@example.com"), institute=instt)
        devs = [dev1, dev2]

        self.assertItemsEqual(instt.get_developers(), devs)

#+END_SRC

*** Tests for Developer
#+BEGIN_SRC python :tangle tests/test_db.py :eval no
class TestDeveloper(TestCase):

    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    # Tests for developer entity
    def test_developer_constructor(self):
        print "test_developer_constructor"
        inst = create_institute("MIT", "mit", "John", "Blake")
        developer = create_developer("Thirumal Ravula",
                                     "travula@gmail.com",
                                     inst)
        print "developer = %s" % developer
        self.assertEqual("Thirumal Ravula", developer.name)
        self.assertEqual("travula@gmail.com", developer.email)

    def test_developer_to_client(self):
        print "test_developer_to_client"
        inst = create_institute("MIT", "mit", "John", "Blake")
        developer = create_developer("Thirumal Ravula",
                                     "travula@gmail.com", inst)
        developer.save()
        dev = Developer.get_by_id(1)
        dev_dict = dev.to_client()
        print dev_dict
        self.assertEqual("travula@gmail.com", dev_dict['email'])
        self.assertEqual("Thirumal Ravula", dev_dict['name'])
        self.assertEqual("MIT", dev_dict['institute']['name'])

    def test_developer_get_id(self):
        print "test_developer_get_id"
        inst = create_institute("MIT", "mit", "John", "Blake")
        developer = create_developer("Thirumal Ravula",
                                     "travula@gmail.com", inst)
        developer.save()
        self.assertEqual(developer.get_id(), 1)

    def test_developer_get_by_id(self):
        print "test_developer_get_by_id"
        inst = create_institute("MIT", "mit", "John", "Blake")
        developer = create_developer("Thirumal Ravula",
                                     "travula@gmail.com", inst)
        developer.save()
        dev = Developer.get_by_id(1)
        self.assertEqual("Thirumal Ravula", dev.name)
        self.assertEqual("travula@gmail.com", dev.email)
        self.assertEqual("MIT", dev.institute.name)
        self.assertEqual("mit", dev.institute.institute_id)


    def test_developer_get_name(self):
        print "test_developer_get_name"
        inst = create_institute("MIT", "mit", "John", "Blake")
        developer = create_developer("Thirumal Ravula",
                                     "travula@gmail.com", inst)
        developer.save()
        dev = Developer.get_by_id(1)
        self.assertEqual("Thirumal Ravula", dev.get_name())

    def test_developer_get_email(self):
        print "test_developer_get_email"
        inst = create_institute("MIT", "mit", "John", "Blake")
        developer = create_developer("Thirumal Ravula",
                                     "travula@gmail.com", inst)
        developer.save()
        dev = Developer.get_by_id(1)
        self.assertEqual("travula@gmail.com", dev.get_email())

    def test_developer_get_all(self):
        print "test_developer_get_all"
        inst = create_institute("MIT", "mit", "John", "Blake")
        developer_1 = create_developer("Thirumal Ravula",
                                     "travula@gmail.com", inst)
        developer_2 = create_developer("Anon Ray",
                                     "anon.ray@gmail.com", inst)
        developer_3 = create_developer("Ambika Kaul",
                                       "ambika@vlabs.ac.in", inst)
        developer_1.save()
        developer_2.save()
        developer_3.save()
        dev_list = Developer.get_all()
        for dev in dev_list:
            print dev
        self.assertEqual("travula@gmail.com", dev_list[0]['email'])
        self.assertEqual("Thirumal Ravula", dev_list[0]['name'])
        self.assertEqual("MIT", dev_list[0]['institute']['name'])
        self.assertEqual("anon.ray@gmail.com", dev_list[1]['email'])
        self.assertEqual("Anon Ray", dev_list[1]['name'])
        self.assertEqual("MIT", dev_list[1]['institute']['name'])
        self.assertEqual("ambika@vlabs.ac.in", dev_list[2]['email'])
        self.assertEqual("Ambika Kaul", dev_list[2]['name'])
        self.assertEqual("MIT", dev_list[2]['institute']['name'])

    def test_developer_get_labs(self):
        # This test case has to be implemented
        print "test_developer_get_labs"
        inst = create_institute("MIT", "mit", "John", "Blake")
        developer = create_developer("Thirumal Ravula",
                                     "travula@gmail.com", inst)
        developer.save()

        devs = [developer]
        lab1 = Lab(name="DS", lab_id="ds", developers=devs)
        lab1.save()
        lab2 = Lab(name="POPL", lab_id="popl", developers=devs)
        lab2.save()
        labs = [lab1, lab2]
        dev = Developer.get_by_id(1)
        get_labs = dev.get_labs()
        for lab in get_labs:
            print lab.name
        self.assertItemsEqual(labs, dev.get_labs())


    def test_developer_get_institute(self):
        print "test_developer_get_institute"
        inst = create_institute("MIT", "mit", "John", "Blake")
        developer = create_developer("Thirumal Ravula",
                                     "travula@gmail.com", inst)
        developer.save()
        dev = Developer.get_by_id(1)
        institute = dev.get_institute()
        print institute.name
        self.assertEqual(inst, institute)

    def test_developer_set_name(self):
        print "test_developer_set_name"
        inst = create_institute("MIT", "mit", "John", "Blake")
        developer = create_developer("Thirumal Ravula",
                                     "travula@gmail.com", inst)
        developer.save()
        developer.set_name(Name("Anon Ray"))
        developer.save()
        dev = Developer.get_by_id(1)
        self.assertEqual("Anon Ray", dev.name)

    def test_developer_set_email(self):
        print "test_developer_set_email"
        inst = create_institute("MIT", "mit", "John", "Blake")
        developer = create_developer("Thirumal Ravula",
                                     "travula@gmail.com", inst)
        developer.save()
        developer.set_email(Email("anon.ray@gmail.com"))
        developer.save()
        dev = Developer.get_by_id(1)
        self.assertEqual("anon.ray@gmail.com", dev.email)

    def test_developer_set_institute(self):
        print "test_developer_set_institute"
        inst = create_institute("MIT", "mit", "John", "Blake")
        developer = create_developer("Thirumal Ravula",
                                     "travula@gmail.com", inst)
        developer.save()
        inst_1 = create_institute("Purdue", "pur", "Venkatesh", "Chopella")
        developer.set_institute(inst_1)
        developer.save()
        dev = Developer.get_by_id(1)
        self.assertEqual(inst_1, dev.institute)

#+END_SRC


*** Tests for Discipline
#+BEGIN_SRC python :tangle tests/test_db.py :eval no
class TestDiscipline(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_discipline_constructor(self):
        print "test_discipline_constructor"
        name = "ECE"
        discipline_id = "ece"
        dnc = Name("Alan Joe")

        disc = Discipline(name=name, discipline_id=discipline_id, dnc=dnc)
        self.assertEqual(isinstance(disc, Discipline), True)

        # Calling the discipline constructor without any arguments should
        # raise AttributeRequired exception
        self.assertRaises(AttributeRequired, Discipline)

        # Calling the discipline constructor without necessary arguments
        # like name and/or discipline_id should raise AttributeRequired exception
        self.assertRaises(AttributeRequired, Discipline,
                          **{'name': 'ECE',
                             'dnc': Name('John')
                            })

        # Calling the discipline constructor with wrong type of arguments
        # should raise TypeError
        self.assertRaises(TypeError, Discipline,
                          **{'name': 'CSE',
                             'discipline_id': 'cse',
                             'dnc': 'Jane'
                            })

    def test_set_discipline_name(self):
        print "test_set_discipline_name"
        disc = Discipline(name="Electrical Engineering", discipline_id="eee")
        new_name = "Electrical"
        disc.set_name(new_name)
        self.assertEqual(disc.name, "Electrical")

    def test_set_discipline_dnc(self):
        print "test_set_discipline_dnc"
        disc = Discipline(name="CSE", discipline_id="cs")
        new_dnc = Name("James roy")
        disc.set_dnc(new_dnc)
        self.assertEqual(disc.dnc, "James roy")
        self.assertRaises(TypeError, disc.set_dnc, "123 James roy")

    def test_get_id(self):
        print "test_get_id_of_discipline"
        disc = Discipline(name="CSE", discipline_id="cs")
        disc.save()
        self.assertEqual(disc.id, disc.get_id())

    def test_get_discipline_name(self):
        print "test_get_discipline_name"
        disc = Discipline(name="CSE", discipline_id="cs")
        disc.save()
        self.assertEqual(disc.get_name(), "CSE")

    def test_get_discipline_dnc(self):
        print "test_get_discipline_dnc"
        disc = Discipline(name="CSE", discipline_id="cs", dnc=Name("James"))
        self.assertEqual(disc.get_dnc(), "James")

    def test_get_discipline_id(self):
        print "test_get_discipline_id"
        disc = Discipline(name="CSE", discipline_id="cs", dnc=Name("James"))
        self.assertEqual(disc.get_discipline_id(), "cs")

    def test_get_by_discipline_id(self):
        print "test_get_by_discipline_id"
        disc = Discipline(name="Computer Science", discipline_id="cse")
        disc.save()
        some_disc = Discipline.get_by_discipline_id("cse")
        self.assertEqual(some_disc, disc)

    def test_get_discipline_by_id(self):
        print "test_get_discipline_by_id"
        disc = Discipline(name="CSE", discipline_id="cs", dnc=Name("James"))
        disc.save()
        self.assertEqual(disc.get_by_id(1).name, disc.name)

    def test_get_discipline_labs(self):
        print "test_get_discipline_labs"
        disc = Discipline(name="Electronics", discipline_id="ece")
        lab1 = Lab(name="Micro Controllers", lab_id="micro", discipline=disc)
        lab2 = Lab(name="Digital Logic Design", lab_id="digital", discipline=disc)
        labs = [lab1, lab2]
        self.assertItemsEqual(disc.get_labs(), labs)

#+END_SRC

*** Tests for Technology

#+BEGIN_SRC python :tangle tests/test_db.py :eval no
class TestTechnology(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_technology_constructor(self):
        print "test_technology_constructor"
        tech = Technology(name="php5", version="5.0")
        self.assertEqual(isinstance(tech, Technology), True)
        self.assertEqual(tech.get_name(), "php5")
        # Calling Technology constructor w/o any argument should raise
        # AttributeRequired exception
        self.assertRaises(AttributeRequired, Technology)
        # Calling Technology constructor w/o required args should raise
        # AttributeRequired exception
        self.assertRaises(AttributeRequired, Technology,
                          **{'version': '5.0', 'foss': False})
        # Calling constructor with req. args but wrong types
        self.assertRaises(TypeError, Technology,
                          **{'name': 45, 'version': '5.0'})

    def test_technology_get_id(self):
        print "test_technology_get_id"
        tech = Technology(name="php5")
        tech.save()
        self.assertEqual(tech.get_id(), 1)

    def test_technology_get_all(self):
        print "test_technology_get_all"
        tech1 = Technology(name="php5")
        tech1.save()
        tech2 = Technology(name="Python")
        tech2.save()
        tech3 = Technology(name="Apache")
        tech3.save()
        techs = Technology.get_all()
        self.assertItemsEqual(techs, [tech1, tech2, tech3])

    def test_technology_get_name(self):
        print "test_technology_get_name"
        tech = Technology(name="php5")
        self.assertEqual(tech.get_name(), "php5")

    def test_technology_get_labs(self):
        print "test_technology_get_labs"
        tech = Technology(name="php5", version="5.0")
        lab1 = Lab(name="DS", lab_id="ds", technologies=[tech])
        lab2 = Lab(name="CG", lab_id="cg", technologies=[tech])
        self.assertItemsEqual(tech.get_labs(), [lab1, lab2])

    def test_technology_get_by_id(self):
        print "test_technology_get_by_id"
        tech = Technology(name="php5")
        tech.save()
        self.assertEqual(Technology.get_by_id(1), tech)

    def test_technology_get_version(self):
        print "test_technology_get_version"
        tech = Technology(name="php5", version="5.5")
        self.assertEqual(tech.get_version(), "5.5")

    def test_technology_is_foss(self):
        print "test_technology_is_foss"
        tech = Technology(name="Python", version="2.7", foss=True)
        self.assertEqual(tech.is_foss(), True)

    def test_technology_set_name(self):
        print "test_technology_set_name"
        tech = Technology(name="Python")
        tech.set_name("Python2.7")
        self.assertEqual(tech.get_name(), "Python2.7")

    def test_technology_set_version(self):
        print "test_technology_set_version"
        tech = Technology(name="Python")
        tech.set_version("2.7.3")
        self.assertEqual(tech.get_version(), "2.7.3")
        # Wrong type of `version` should throw TypeError
        self.assertRaises(TypeError, tech.set_version, 2.7)

    def test_technology_set_foss(self):
        print "test_technology_set_foss"
        tech = Technology(name="Python")
        tech.set_foss(True)
        self.assertEqual(tech.is_foss(), True)
        # Wrong type of `version` should throw TypeError
        self.assertRaises(TypeError, tech.set_foss, "Yes")

#+END_SRC

*** Tests for Experiment
#+BEGIN_SRC python :tangle tests/test_db.py :eval no
class TestExperiment(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_experiment_constructor(self):
        print "test_experiment_constructor"
        name = "Searching and Sorting"
        content_url = URL("http://deploy.virtual-labs.ac.in/labs/cse04/exp1/index.php")
        simulation_url = URL("http://deploy.virtual-labs.ac.in/labs/cse04/exp1/lab.html")

        lab = Lab(name="DS", lab_id="ds")

        expt = Experiment(name=name, lab=lab, content_url=content_url, simulation_url=simulation_url)
        self.assertEqual(isinstance(expt, Experiment), True)

        # Calling the experiment constructor without any arguments should
        # raise AttributeRequired exception
        self.assertRaises(AttributeRequired, Experiment)

        # Calling the experiment constructor without name/lab argument
        # should raise AttributeRequired exception
        self.assertRaises(AttributeRequired, Experiment,
                          **{'content_url': URL('http://deploy.virtual-labs.ac.in/labs/cse04/exp1/index.php'),
                            })

        # Calling the experiment constructor with wrong type of
        # arguments should raise TypeError
        self.assertRaises(TypeError, Experiment,
                          **{'name': 'Searching and Sorting',
                             'lab': lab,
                             'content_url': ('http://deploy.virtual-labs.ac.in/labs/cse04/exp1/index.php')
                            })

    def test_get_content_url(self):
        print "test_experiment_get_content_url"
        lab = Lab(name="DS", lab_id="ds")
        expt = Experiment(name="Searching and Sorting", lab=lab, content_url=URL("http://vlabs.ac.in"))
        self.assertEqual(expt.get_content_url(), "http://vlabs.ac.in")

    def test_get_simulation_url(self):
        print "test_experiment_get_simulation_url"
        lab = Lab(name="DS", lab_id="ds")
        expt = Experiment(name="Searching and Sorting", lab=lab, simulation_url=URL("http://vlabs.ac.in"))
        self.assertEqual(expt.get_simulation_url(), "http://vlabs.ac.in")

    def test_get_id_of_experiment(self):
        print "test_get_id_of_experiment"
        lab = Lab(name="DS", lab_id="ds")
        expt = Experiment(name="Simple Pendulum", lab=lab)
        expt.save()
        expt_id = expt.get_id()
        self.assertEqual(expt_id, 1)

    def test_get_experiment_by_id(self):
        print "test_get_experiment_by_id"
        lab = Lab(name="DS", lab_id="ds")
        expt = Experiment(name="Simple Pendulum", lab=lab)
        expt.save()
        self.assertEqual(expt.get_by_id(1).name, "Simple Pendulum")

    def test_get_experiment_technologies(self):
        print "test_get_experiment_technologies"
        tech1 = Technology(name="php5")
        tech2 = Technology(name="apache2")
        techs = [tech1, tech2]
        lab = Lab(name="DS", lab_id="ds")
        expt = Experiment(name="Simple Pendulum", lab=lab, technologies=techs)
        self.assertItemsEqual(expt.get_technologies(), techs)

    def test_experiment_add_technology(self):
        print "test_experiment_add_technology"
        lab = Lab(name="DS", lab_id="ds")
        expt = Experiment(name="Pendulum", lab=lab)
        tech = Technology(name="php5")
        self.assertEqual(len(expt.get_technologies()), 0)
        expt.add_technology(tech)
        self.assertEqual(len(expt.get_technologies()), 1)

    def test_experiment_remove_technology(self):
        print "test_experiment_remove_technology"
        tech = Technology(name="php5")
        lab = Lab(name="DS", lab_id="ds")
        expt = Experiment(name="Pendulum", lab=lab, technologies=[tech])
        self.assertEqual(len(expt.get_technologies()), 1)
        expt.remove_technology(tech)
        self.assertEqual(len(expt.get_technologies()), 0)

    def test_get_experiment_lab(self):
        print "test_get_experiment_lab"
        lab = Lab(name="Data Structures", lab_id="dsa")
        expt = Experiment(name="Merge Sort", lab=lab)
        self.assertEqual(expt.get_lab(), lab)

    def test_experiment_content_hosted_on(self):
        print "test_get_content_hosted_on"
        lab = Lab(name="DS", lab_id="ds")
        platform = HostingPlatform(name="IIIT")
        expt = Experiment(name="Simple Pendulum", lab=lab, content_hosted_on=platform)
        self.assertEqual(expt.get_content_hosted_on(), platform)

    def test_experiment_simulation_hosted_on(self):
        print "test_get_simulation_hosted_on"
        lab = Lab(name="DS", lab_id="ds")
        platform = HostingPlatform(name="IIIT")
        expt = Experiment(name="Simple Pendulum", lab=lab, simulation_hosted_on=platform)
        self.assertEqual(expt.get_simulation_hosted_on(), platform)

    def test_set_experiment_content_url(self):
        print "test_set_experiment_content_url"
        lab = Lab(name="DS", lab_id="ds")
        expt = Experiment(name="Simple Pendulum", lab=lab)
        url = URL("http://vlabs.ac.in")
        expt.set_content_url(url)
        self.assertEqual(expt.get_content_url(), "http://vlabs.ac.in")

    def test_set_experiment_simulation_url(self):
        print "test_set_experiment_simulation_url"
        lab = Lab(name="DS", lab_id="ds")
        expt = Experiment(name="Simple Pendulum", lab=lab)
        url = URL("http://vlabs.ac.in")
        expt.set_simulation_url(url)
        self.assertEqual(expt.get_simulation_url(), "http://vlabs.ac.in")

    def test_set_experiment_content_hosted_on(self):
        print "test_set_content_hosted_on"
        lab = Lab(name="DS", lab_id="ds")
        expt = Experiment(name="Pendulum", lab=lab)
        plat = HostingPlatform(name="IIIT")
        expt.set_content_hosted_on(plat)
        self.assertEqual(expt.get_content_hosted_on(), plat)
        self.assertRaises(TypeError, expt.set_content_hosted_on, "AWS")

    def test_set_experiment_simulation_hosted_on(self):
        print "test_set_simulation_hosted_on"
        lab = Lab(name="DS", lab_id="ds")
        expt = Experiment(name="Pendulum", lab=lab)
        plat = HostingPlatform(name="IIIT")
        expt.set_simulation_hosted_on(plat)
        self.assertEqual(expt.get_simulation_hosted_on(), plat)

#+END_SRC

*** Run the tests
#+BEGIN_SRC python :tangle tests/test_db.py :eval no

if __name__ == '__main__':
    unittest.main()

#+END_SRC

** Testing the REST API
*** Imports and initialization of testcases

#+BEGIN_SRC python :tangle tests/test_api.py :eval no
# -*- coding: utf-8 -*-

import unittest
from flask.ext.testing import TestCase
# import json

from src.db import *
from tests.helper import *
from src.app import create_app
from src.ds_exceptions import AttributeRequired

config = {
    'SQLALCHEMY_DATABASE_URI': ''
}
#+END_SRC

*** Tests for Lab
#+BEGIN_SRC python :tangle tests/test_api.py :eval no
class TestLab(TestCase):

    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_get_all_labs(self):
        print "test_get_all_labs"
        lab1 = Lab(name="DS", lab_id="cse01")
        lab1.save()
        lab2 = Lab(name="Foo", lab_id="cse23")
        lab2.save()
        r = self.client.get('/labs')
        result = json.loads(r.data)
        self.assertEquals(len(result), 2)

    def test_get_one_lab(self):
        print "test_get_one_lab"
        lab1 = Lab(name="DS", lab_id="cse01")
        lab1.save()
        lab2 = Lab(name="Foo", lab_id="cse23")
        lab2.save()
        r = self.client.get('/labs/1')
        result = json.loads(r.data)
        self.assertEqual(result['name'], "DS")

    def test_update_existing_lab(self):
        print "test_update_existing_lab"
        instt = Institute(name="MIT", institute_id="mit")
        instt.save()
        print instt.to_client()
        lab1 = Lab(name="DS", lab_id="cse01")
        lab1.save()
        r = self.client.put('/labs/1',
                            data=json.dumps({'institute': instt.to_client()}))
        result = json.loads(r.data)
        self.assertEqual(result['institute']['name'], "MIT")

    def test_create_new_lab(self):
        print "test_create_new_lab"
        r = self.client.post('/labs', data={'name': 'DS', 'lab_id': 'ds'})
        result = json.loads(r.data)
        self.assertEqual(result['name'], "DS")

    def test_delete_lab(self):
        print "test_delete_lab"
        lab1 = Lab(name="DS", lab_id="cse01")
        lab1.save()
        lab2 = Lab(name="Foo", lab_id="cse23")
        lab2.save()
        r = self.client.delete('/labs/2')
        r = self.client.get('/labs')
        result = json.loads(r.data)
        self.assertEqual(len(result), 1)

#+END_SRC

*** Tests for Experiment
#+BEGIN_SRC python :tangle tests/test_api.py :eval no
class TestExperiment(TestCase):

    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_get_all_experiments(self):
        print "test_get_all_experiments"
        lab1 = Lab(name="DS", lab_id="cse01")
        lab1.save()
        exp1 = Experiment(name="Spanning Tree", lab=lab1)
        exp1.save()
        exp2 = Experiment(name="Lists", lab=lab1)
        exp2.save()
        r = self.client.get('/experiments')
        result = json.loads(r.data)
        print result
        self.assertEquals(len(result), 2)

    def test_get_one_experiment(self):
        print "test_get_one_experiment"
        lab1 = Lab(name="DS", lab_id="cse01")
        lab1.save()
        exp1 = Experiment(name="Spanning Tree", lab=lab1)
        exp1.save()
        exp2 = Experiment(name="Lists", lab=lab1)
        exp2.save()
        r = self.client.get('/experiments/1')
        result = json.loads(r.data)
        print result
        self.assertEqual(result['name'], "Spanning Tree")

    def test_update_existing_experiment(self):
        print "test_update_existing_experiment"
        lab1 = Lab(name="DS", lab_id="cse01")
        lab1.save()
        platform = HostingPlatform(name="Digital Ocean")
        platform.save()
        exp1 = Experiment(name="Spanning Tree", lab=lab1)
        exp1.save()
        r = self.client.put('/experiments/1',
                            data=json.dumps({'simulation_hosted_on':
                                             platform.to_client()}))
        result = json.loads(r.data)
        self.assertEqual(result['simulation_hosted_on']['name'], "Digital Ocean")

    def test_create_new_experiment(self):
        print "test_create_new_experiment"
        lab1 = Lab(name="DS", lab_id="cse01")
        lab1.save()
        r = self.client.post('/experiments',
                             data=json.dumps({'name': 'Spanning Tree',
                                              'lab': lab1.to_client()}))
        result = json.loads(r.data)
        self.assertEqual(result['name'], "Spanning Tree")

    def test_delete_experiment(self):
        print "test_delete_experiment"
        lab1 = Lab(name="DS", lab_id="cse01")
        lab1.save()
        exp1 = Experiment(name="Spanning Tree", lab=lab1)
        exp1.save()
        exp2 = Experiment(name="Lists", lab=lab1)
        exp2.save()
        r = self.client.delete('/experiments/1')
        r = self.client.get('/experiments')
        result = json.loads(r.data)
        self.assertEqual(len(result), 1)

#+END_SRC

*** Tests for Technology
#+BEGIN_SRC python :tangle tests/test_api.py :eval no
class TestTechnology(TestCase):

    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_get_all_technologies(self):
        print "test_get_all_technologies"
        tech1 = Technology(name="php5")
        tech1.save()
        tech2 = Technology(name="mysql")
        tech2.save()
        r = self.client.get('/technologies')
        result = json.loads(r.data)
        print result
        self.assertEquals(len(result), 2)

    def test_get_one_technology(self):
        print "test_get_one_technology"
        tech1 = Technology(name="php5")
        tech1.save()
        tech2 = Technology(name="mysql")
        tech2.save()
        r = self.client.get('/technologies/1')
        result = json.loads(r.data)
        print result
        self.assertEqual(result['name'], "php5")

    def test_update_existing_technology(self):
        print "test_update_existing_technology"
        tech1 = Technology(name="php5")
        tech1.save()
        r = self.client.put('/technologies/1',
                            data=json.dumps({'version': '5.3', 'foss': True}))
        result = json.loads(r.data)
        self.assertEqual(result['version'], "5.3")

    def test_create_new_technology(self):
        print "test_create_new_technology"
        r = self.client.post('/technologies',
                             data=json.dumps({'name': 'php5', 'version': '5.2',
                                              'foss': True}))
        result = json.loads(r.data)
        self.assertEqual(result['name'], "php5")

    def test_delete_technology(self):
        print "test_delete_technology"
        tech1 = Technology(name="php5")
        tech1.save()
        tech2 = Technology(name="mysql")
        tech2.save()
        r = self.client.delete('/technologies/1')
        r = self.client.get('/technologies')
        result = json.loads(r.data)
        self.assertEqual(len(result), 1)

#+END_SRC

*** Tests for Developer
#+BEGIN_SRC python :tangle tests/test_api.py :eval no
class TestDeveloper(TestCase):

    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_get_all_developers(self):
        print "test_get_all_developers"
        instt = Institute(name="MIT", institute_id="mit")
        instt.save()
        dev1 = Developer(name=Name("Joe Smith"),
                         email=Email("joe@smith.com"),
                         institute=instt)
        dev1.save()
        dev2 = Developer(name=Name("Will Smith"),
                         email=Email("will@smith.com"),
                         institute=instt)
        dev2.save()
        r = self.client.get('/developers')
        result = json.loads(r.data)
        print result
        self.assertEquals(len(result), 2)

    def test_get_one_developer(self):
        print "test_get_one_developer"
        instt = Institute(name="MIT", institute_id="mit")
        instt.save()
        dev1 = Developer(name=Name("Joe Smith"),
                         email=Email("joe@smith.com"),
                         institute=instt)
        dev1.save()
        dev2 = Developer(name=Name("Will Smith"),
                         email=Email("will@smith.com"),
                         institute=instt)
        dev2.save()
        r = self.client.get('/developers/1')
        result = json.loads(r.data)
        print result
        self.assertEqual(result['name'], "Joe Smith")

    def test_update_existing_developer(self):
        print "test_update_existing_developer"
        instt = Institute(name="MIT", institute_id="mit")
        instt.save()
        dev1 = Developer(name=Name("Joe Smith"),
                         email=Email("joe@smith.com"),
                         institute=instt)
        dev1.save()
        r = self.client.put('/developers/1',
                            data=json.dumps({'email': 'joe@mit.edu'}))
        result = json.loads(r.data)
        self.assertEqual(result['email'], "joe@mit.edu")

    def test_create_new_developer(self):
        print "test_create_new_developer"
        instt = Institute(name="MIT", institute_id="mit")
        instt.save()
        r = self.client.post('/developers',
                             data=json.dumps({'name': 'Joe Smith',
                                              'email': 'joe@mit.edu',
                                              'institute': instt.to_client()}))
        result = json.loads(r.data)
        self.assertEqual(result['name'], "Joe Smith")

    def test_delete_developer(self):
        print "test_delete_developer"
        instt = Institute(name="MIT", institute_id="mit")
        instt.save()
        dev1 = Developer(name=Name("Joe Smith"),
                         email=Email("joe@smith.com"),
                         institute=instt)
        dev1.save()
        dev2 = Developer(name=Name("Will Smith"),
                         email=Email("will@smith.com"),
                         institute=instt)
        dev2.save()
        r = self.client.delete('/developers/1')
        r = self.client.get('/developers')
        result = json.loads(r.data)
        self.assertEqual(len(result), 1)

#+END_SRC

*** Tests for Discipline
#+BEGIN_SRC python :tangle tests/test_api.py :eval no
class TestDiscipline(TestCase):

    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_get_all_disciplines(self):
        print "test_get_all_disciplines"
        disc1 = Discipline(name="Computer Science", discipline_id="cse")
        disc1.save()
        disc2 = Discipline(name="Electronics", discipline_id="ece")
        disc2.save()
        r = self.client.get('/disciplines')
        result = json.loads(r.data)
        print result
        self.assertEquals(len(result), 2)

    def test_get_one_disciplines(self):
        print "test_get_one_disciplines"
        disc1 = Discipline(name="Computer Science", discipline_id="cse")
        disc1.save()
        disc2 = Discipline(name="Electronics", discipline_id="ece")
        disc2.save()
        r = self.client.get('/disciplines/1')
        result = json.loads(r.data)
        print result
        self.assertEqual(result['name'], "Computer Science")

    def test_update_existing_discipline(self):
        print "test_update_existing_discipline"
        disc1 = Discipline(name="Computer Science", discipline_id="cse")
        disc1.save()
        disc2 = Discipline(name="Electronics", discipline_id="ece")
        disc2.save()
        r = self.client.put('/disciplines/1',
                            data=json.dumps({'dnc': 'Gerald Sussman'}))
        result = json.loads(r.data)
        self.assertEqual(result['dnc'], "Gerald Sussman")

    def test_create_new_discipline(self):
        print "test_create_new_discipline"
        r = self.client.post('/disciplines',
                             data=json.dumps({'name': 'Humanities',
                                              'discipline_id': 'hmt',
                                              'dnc': 'Noam Chomsky'}))
        result = json.loads(r.data)
        self.assertEqual(result['name'], "Humanities")

    def test_delete_discipline(self):
        print "test_delete_discipline"
        disc1 = Discipline(name="Computer Science", discipline_id="cse")
        disc1.save()
        disc2 = Discipline(name="Electronics", discipline_id="ece")
        disc2.save()
        r = self.client.delete('/disciplines/1')
        r = self.client.get('/disciplines')
        result = json.loads(r.data)
        self.assertEqual(len(result), 1)

#+END_SRC

*** Tests for Institute
#+BEGIN_SRC python :tangle tests/test_api.py :eval no
class TestInstitute(TestCase):

    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_get_all_institutes(self):
        print "test_get_all_institutes"
        instt1 = Institute(name="MIT", institute_id="mit")
        instt1.save()
        instt2 = Institute(name="IIT", institute_id="iit")
        instt2.save()
        r = self.client.get('/institutes')
        result = json.loads(r.data)
        print result
        self.assertEquals(len(result), 2)

    def test_get_one_institute(self):
        print "test_get_one_institute"
        instt1 = Institute(name="MIT", institute_id="mit")
        instt1.save()
        instt2 = Institute(name="IIT", institute_id="iit")
        instt2.save()
        r = self.client.get('/institutes/1')
        result = json.loads(r.data)
        print result
        self.assertEqual(result['name'], "MIT")

    def test_update_existing_institute(self):
        print "test_update_existing_institute"
        instt1 = Institute(name="MIT", institute_id="mit")
        instt1.save()
        instt2 = Institute(name="IIT", institute_id="iit")
        instt2.save()
        r = self.client.put('/institutes/1',
                            data=json.dumps({'pic': 'Gerald Sussman'}))
        result = json.loads(r.data)
        self.assertEqual(result['pic'], "Gerald Sussman")

    def test_create_new_institute(self):
        print "test_create_new_institute"
        r = self.client.post('/institutes',
                             data=json.dumps({'name': 'Quest University',
                                              'institute_id': 'quest',
                                              'pic': 'Noam Chomsky'}))
        result = json.loads(r.data)
        self.assertEqual(result['name'], "Quest University")

    def test_delete_institute(self):
        print "test_delete_institute"
        instt1 = Institute(name="MIT", institute_id="mit")
        instt1.save()
        instt2 = Institute(name="IIT", institute_id="iit")
        instt2.save()
        r = self.client.delete('/institutes/1')
        r = self.client.get('/institutes')
        result = json.loads(r.data)
        self.assertEqual(len(result), 1)

#+END_SRC

*** Tests for Feedback
#+BEGIN_SRC python :tangle tests/test_api.py :eval no
class TestFeedback(TestCase):

    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_get_all_feedbacks(self):
        print "test_get_all_feedbacks"
        lab = Lab(name="DS", lab_id="ds")
        lab.save()
        f1 = Feedback(lab=lab)
        f1.save()
        f2 = Feedback(lab=lab)
        f2.save()
        r = self.client.get('/feedback')
        result = json.loads(r.data)
        print result
        self.assertEquals(len(result), 2)

    def test_get_one_feedback(self):
        print "test_get_one_feedback"
        lab = Lab(name="DS", lab_id="ds")
        lab.save()
        f1 = Feedback(lab=lab)
        f1.save()
        f2 = Feedback(lab=lab)
        f2.save()
        r = self.client.get('/feedback/1')
        result = json.loads(r.data)
        print result
        self.assertEqual(result['lab']['name'], "DS")

    def test_update_existing_feedback(self):
        print "test_update_existing_feedback"
        lab = Lab(name="DS", lab_id="ds")
        lab.save()
        f1 = Feedback(lab=lab)
        f1.save()
        f2 = Feedback(lab=lab)
        f2.save()
        r = self.client.put('/feedback/1',
                            data=json.dumps({'type_of_user': 'student'}))
        self.assert_500(r)

    def test_create_new_feedback(self):
        print "test_create_new_feedback"
        lab = Lab(name="DS", lab_id="ds")
        lab.save()
        r = self.client.post('/feedback',
                             data=json.dumps({'lab': {'id': 1},
                                              'user_name': 'john',
                                              'user_email': 'john@foo.com',
                                              'ip': '10.2.3.2',
                                              'type_of_user': 'student',
                                              'suggestions': 'blah'}))
        result = json.loads(r.data)
        self.assertEqual(result['user_name'], "john")

    def test_delete_feedback(self):
        print "test_delete_feedback"
        lab = Lab(name="DS", lab_id="ds")
        lab.save()
        f1 = Feedback(lab=lab)
        f1.save()
        f2 = Feedback(lab=lab)
        f2.save()
        r = self.client.delete('/feedback/1')
        self.assert_500(r)

#+END_SRC

*** Run the tests
#+BEGIN_SRC python :tangle tests/test_api.py :eval no

if __name__ == '__main__':
    unittest.main()

#+END_SRC

** Helper Functions
#+BEGIN_SRC python :tangle tests/helper.py :eval no
from src.db import *


def create_institute(_name, _institute_id, _pic, _iic):
    __name = _name
    __pic = Name(_pic)
    __iic = Name(_iic)
    return Institute(name=__name, institute_id=_institute_id, pic=__pic, iic=__iic)


def create_developer(_name, _email, _inst):
    __name = Name(_name)
    __email = Email(_email)
    return Developer(name=__name, email=__email, institute=_inst)

#+END_SRC

* Provisioning
  [[./setup.org][Set up the environment]]
* Design discussions

* Releases


** v0.1.0
    This release will satisfy requirements 1 & 2
    Release Date :: [2015-08-26 Wed]
*** Tasks & Deadlines
**** DONE Data Model
     + Tasks
       - Describe each entity and capture the model of data for each entity.
       - Describe the relationship between all the entities.

**** TODO Python API ,
     + Completion Data :: [2015-08-26 Wed]
     + Completed Date ::
     + Tasks
       - Provide Python API to perform CRUD operations on different entities.
*** Hours
    |------------------+----------+------+--------+-------+---|
    | Date             | Thirumal | Anon | Ambika | Total |   |
    |------------------+----------+------+--------+-------+---|
    | [2015-08-24 Mon] |        6 |    6 |      7 |    19 |   |
    |------------------+----------+------+--------+-------+---|
    | [2015-08-25 Tue] |        6 |    6 |      7 |    19 |   |
    |------------------+----------+------+--------+-------+---|
    | [2015-08-26 Wed] |        6 |    6 |      7 |    19 |   |
    |------------------+----------+------+--------+-------+---|
    | [2015-08-27 Thu] |        6 |    5 |      7 |    18 |   |
    |------------------+----------+------+--------+-------+---|
    | Total            |          |      |        |    75 |   |
    |------------------+----------+------+--------+-------+---|


** v0.2.0
    This release is tracked here:
    https://issues.vlabs.ac.in/projects/release-v0-2-0
    Requirements for the release are tracked in the above.
    This release will satisfy requirements 3
    Release Date ::
**** TODO REST API and Migration scripts from old data to new model
***** Tasks
      1. Provide REST API for different application to perform CRUD
         operations on different entities.
      2. Provide a migration script that converts the legacy data into the
         new data model.



** v1.0.0
**** TODO Provisioning
